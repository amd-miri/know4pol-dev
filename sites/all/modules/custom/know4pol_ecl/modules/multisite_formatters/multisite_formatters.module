<?php

/**
 * @file
 * Defines custom Nexteuropa components field formatters.
 */

 /**
 * Implements hook_theme().
 */
function multisite_formatters_theme($existing, $type, $theme, $path) {
  $templates_path = sprintf('%s/templates', $path);

  return array(
    'tag' => array(
      'variables' => array(
        'items' => NULL,
        'group_label' => NULL,
      ),
      'template' => 'tag',
      'path' => $templates_path,
    ),
  );
}
 
 
/**
 * Implements hook_field_formatter_info().
 */
function multisite_formatters_field_formatter_info() {
  return array(
    'ecl_tags' => array(
      'label' => t('ECL tags'),
      'description' => t('Format as ECL Reference tags.'),
      'field types' => array(
        'link_field',
        'taxonomy_term_reference',
        'entityreference',
      ),
      'settings' => array(
        'link' => 'default',
        'solr' => 'default',
        'solr_include' => '',
        'rewrite' => '',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function multisite_formatters_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $element = array();

  // Switch for the different formatters.
  switch ($display['type']) {
    case 'ecl_tags':
      $element['link'] = array(
        '#type' => 'select',
        '#title' => t('Link to'),
        '#options' => array(
          'default' => t('Drupal default'),
          'solr' => t('SolR search page as facet enabled'),
          'custom' => t('Custom / Rewrite'),
          'none' => 'No link',
        ),
        '#default_value' => $settings['link'],
        '#description' => t('Define where the URL of the tag should link. Default is Drupal\'s default behaviour'),
      );
      // Restrict options for field type link
      if ($field['type'] == 'link_field') {
        unset ($element['link']['#options']['solr']);  
        unset ($element['link']['#options']['custom']);  
      } 
        

      
      if(module_exists('apachesolr')) {
        $solr_pages = Array();
        // Get solr pages to display in select.
        foreach(apachesolr_search_load_all_search_pages() as $key => $item) {
          $solr_pages[$key] =  $item['description'] != '' ? $item['description'] : $item['page_title'];
        }
      }
      else $solr_pages = ['Apache solr not installed'];
      
      $element['solr'] = array(
        '#type' => 'select',
        '#title' => t('SolR page to link to'),
        '#options' => $solr_pages,
        '#default_value' => $settings['solr'],
        '#description' => t('The Apache SolR page it will link to. (facets will be preselected using machine name)'),
        '#states' => array(
          'visible' => array(
            'select[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][link]"' => array('value' => 'solr'),
          ),
        ),
      );
      $element['solr_include'] = array(
        '#type' => 'textfield',
        '#title' => t('Include other fields as facets'),
        '#default_value' => $settings['solr_include'],
        '#description' => t('Specify a comma separated list of fields machine name of the content to pass to the SolR page'),
        '#token_insert' => TRUE,
        '#states' => array(
          'visible' => array(
            'select[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][link]"' => array('value' => 'solr'),
          ),
        ),
      );
      
      $element['rewrite'] = array(
        '#type' => 'textfield',
        '#title' => t('Custom URL'),
        '#default_value' => $settings['rewrite'],
        '#description' => t('You can rewrite the URL with tokens.'),
        '#token_insert' => TRUE,
        '#states' => array(
          'visible' => array(
            'select[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][link]"' => array('value' => 'custom'),
          ),
        ),
      );

      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function multisite_formatters_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $summary = array();

  // Switch for the different formatters.
  switch ($display['type']) {
    case 'ecl_tags':
      switch($settings['link']) {
        case 'default':
          $summary[] = t('Link to ') . t('Drupal default');
          break;
        
        case 'solr':
          $summary[] = t('Link to SolR search page: @page', array(
            '@page' => $settings['solr'],
          ));
          if (isset($settings['solr_include']) && $settings['solr_include'] != '') {
            $summary[] = t('with added fields as facets: @solr_include', array(
              '@solr_include' => $settings['solr_include'],
            ));
          }
          
          break;
      
        case 'custom':
          if (isset($settings['rewrite'])) {
            $summary[] = t('Link to custom URL: @rewrite', array(
              '@rewrite' => $settings['rewrite'],
            ));
          }
          break;
          
        case 'none':
          $summary[] = t('No link');
          break;
        
        default:
          $summary[] = t('Not configured');
          break;
      }
      
  }
  $summary = implode('<br />', $summary);

  return $summary;
}

/**
 * Implements hook_field_formatter_prepare_view().
 */
function multisite_formatters_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {

  foreach ($entities as $id => $entity) {
    $display = $displays[$id];
    
    switch ($display['type']) {
      case 'ecl_tags':        
        // Load URL into the items
        switch ($field['type']) {
          case 'taxonomy_term_reference':
            // Load all terms
            $terms = taxonomy_term_load_multiple($items[$id]);
            foreach ($items[$id] as $delta => &$item) {
              if($terms[$item['tid']]) {
                $item['label'] = $terms[$item['tid']]->name;
                $item['url'] = base_path() . drupal_get_path_alias(taxonomy_term_uri($terms[$item['tid']])['path']);
              }
              else {
                unset($items[$id]);
              } 
            }          
            break;
          
          case 'entityreference':
            foreach ($items[$id] as $delta => &$item) {
              krumo($item['target_id']);
              $entity = entity_load('node', [$item['target_id']]);
              krumo($entity);
              $item['label'] = $entity[6661]->title;
              $item['url'] = entity_uri('node', $entity[6661])['path'];
              
            }
            
            break;
          
          case 'link_field':
            foreach ($items[$id] as $delta => &$item) {
              $item['label'] = $item['title'];
            }
               
            break;
        }
        
        // Process links with settings
        foreach ($items[$id] as $delta => &$item) {
          switch ($display['settings']['link']) {
            case 'none':
              unset($item['url']);
              break;

            case 'custom':
            case 'solr':
              
              break;
          } 
        }
        
      break;   
    } 
  }
   
 
   //  krumo($items);
   
    return;
  
  
  // prepare url / lablel (group ?)
  
  $display_modes = array('ecl_tags');
  $target_ids = array();
  $target_type = FALSE;
  $column = NULL;

  // Collect every possible entity attached to any of the entities.
  foreach ($entities as $id => $entity) {
    if (in_array($displays[$id]['type'], $display_modes)) {
      if (is_null($column)) {
        $field_type_settings = entityreference_field_type_settings($field);
        $target_type = $field_type_settings['entity_type'];
        $column = $field_type_settings['column'];
      }

      foreach ($items[$id] as $delta => $item) {
        if (isset($item[$column])) {
          $target_ids[] = $item[$column];
        }
      }
    }
  }

  // If not target ids, no need to continue the process.
  if (empty($target_ids)) {
    return;
  }

  $target_entities = array();
  if ($target_ids) {
    $target_entities = entity_load($target_type, $target_ids);
  }

  // Iterate through the fieldable entities again to attach the loaded data.
  foreach ($entities as $id => $entity) {
    $rekey = FALSE;

    foreach ($items[$id] as $delta => $item) {
      // Check whether the referenced entity could be loaded.
      if (isset($target_entities[$item[$column]])) {
        // Replace the instance value with the term data.
        $items[$id][$delta]['entity'] = $target_entities[$item[$column]];
        // Check whether the user has access to the referenced entity.
        $has_view_access = (entity_access('view', $target_type, $target_entities[$item[$column]]) !== FALSE);
        $has_update_access = (entity_access('update', $target_type, $target_entities[$item[$column]]) !== FALSE);
        $items[$id][$delta]['access'] = ($has_view_access || $has_update_access);
      }
      // Otherwise, unset the instance value, since the entity does not exist.
      else {
        unset($items[$id][$delta]);
        $rekey = TRUE;
      }
    }
    if ($rekey) {
      // Rekey the items array.
      $items[$id] = array_values($items[$id]);
    }
  }
  
  
  krumo($items);
  return;
  

}

/**
 * Implements hook_field_formatter_view().
 */
function multisite_formatters_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();
  $settings = $display['settings'];

  // Switch for the different formatters.
  switch ($display['type']) {
    case 'ecl_tags': 
      $elements[0] = array(
        '#theme' => 'tag',
        '#items' => $items,
        '#group_label' => $group_label,
      );
    break;
  }
  

  return $elements;

  if ($field['type'] === 'taxonomy_term_reference' || $field['type'] === 'entityreference') {
    $field_type_settings = entityreference_field_type_settings($field);
    $target_type = $field_type_settings['entity_type'];
  }

  // Switch for the different formatters.
  switch ($display['type']) {
    case 'ecl_tags': 
      foreach ($items as $delta => $item) {
        switch ($field['type']) {
          case 'taxonomy_term_reference':
          case 'entityreference':
            // If the access is denied to the term, we do not display it.
            if (empty($item['access'])) {
              continue;
            }
            // Calling EntityReferenceHandler::getLabel() would make a repeated,
            // wasteful call to entity_access().
            $label = entity_label($target_type, $item['entity']);
            $uri = entity_uri($target_type, $item['entity']);

            $elements[$delta] = array(
              'value' => $label,
              'href' => $uri['path'],
            );
            break;

          case 'link_field':
            $elements[$delta] = array(
              'value' => $item['title'],
              'href' => $item['url'],
            );
            break;
        }
      }
      break;
    }
 
}

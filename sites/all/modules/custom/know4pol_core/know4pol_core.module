<?php

/**
 * @file
 * Code for the know4pol-core feature.
 */

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_user_admin_permissions_alter(&$form, &$form_state, $form_id) {
  $form['role_permissions'] = array(
    '#type' => 'value',
    '#value' => array(),
  );
  foreach ($form['role_names'] as $rid => $role) {
    if (strpos($rid, '#') !== FALSE) {
      continue;
    }
    $role_permissions = user_role_permissions(array($rid => $rid));
    $form['role_permissions']['#value'][$rid] = $role_permissions[$rid];
  }
  $form['#submit'][] = '_know4pol_core_form_user_admin_permissions_alter_submit';
}

/**
 * Log the changed user permissions.
 *
 * @param string $form
 *   The submitted form.
 * @param string $form_state
 *   The submitted form states.
 */
function _know4pol_core_form_user_admin_permissions_alter_submit(&$form, &$form_state) {
  global $user;
  foreach ($form['role_permissions']['#value'] as $rid => $role_permissions) {
    $data = array();
    foreach ($form_state['values'][$rid] as $permission => $value) {
      if (!isset($role_permissions[$permission])) {
        if ($value) {
          $data[$permission] = 1;
        }
      }
      elseif (!$role_permissions[$permission] && $value) {
        $data[$permission] = 1;
      }
      elseif ($role_permissions[$permission] && !$value) {
        $data[$permission] = 0;
      }
    }
    if (count($data)) {
      watchdog('permissions_changes',
        'The user "%user" changed the following permission(s) for the role "%role" to : %permissions',
        array(
          '%user' => $user->name,
          '%permissions' => print_r($data, TRUE),
          '%role' => $form['role_names'][$rid]['#markup'],
        ),
        WATCHDOG_NOTICE,
        NULL);
    }
  }
}

/**
 * Implements hook_permission().
 */
function know4pol_core_permission() {
  return array(
    'menu view unpublished' => array(
      'title' => t('View unpublished menu links'),
    ),
  );
}

/**
 * Implements hook_og_permission().
 */
function know4pol_core_og_permission() {
  return array(
    'menu OG view unpublished' => array(
      'title' => t('View OG unpublished menu links'),
    ),
  );
}

/**
 * Implements hook_query_TAG_alter().
 *
 * @see menu_tree_check_access()
 *   Contains the query being altered here.
 *   This is most likely the only query with tag node_access
 *   where the first condition is for the node.status column.
 */
function know4pol_core_query_node_access_alter(QueryAlterableInterface $query) {
  // We want to show unpulished menu links to some roles.
  // First we check if we're in an organic group
  // if yes, then we get the related group ID.
  $gid = "";
  $node = menu_get_object();
  // We check if we're in a content_type related to OG fields.
  if (isset($node->og_group_ref)) {
    // Then we check if the current page is the main page of the sub-site.
    if (isset($node->group_group[LANGUAGE_NONE][0]['value']) && ($node->group_group[LANGUAGE_NONE][0]['value'] == 1)) {
      $gid = $node->nid;
    }
    // Or if it's a sub-page of the sub-site.
    elseif (!empty($node->og_group_ref)) {
      $gid = $node->og_group_ref[LANGUAGE_NONE][0]['target_id'];
    }
  }
  // Then we check
  // if the current user has the drupal 'menu view unpublished' permission
  // Or the organic group one which is 'menu OG view unpublished'.
  if (user_access('menu view unpublished')
     || (!empty($gid) && (og_user_access('node', $gid, 'menu OG view unpublished')))
     ) {
    $c = &$query->conditions();
    // Remove the status condition if we suspect this query originates from
    // menu_tree_check_access().
    if (count($c) == 3 &&
      is_string($c[0]['field']) && $c[0]['field'] == 'n.status' &&
      is_string($c[1]['field']) && $c[1]['field'] == 'n.nid' && $c[1]['operator'] == 'IN') {
      unset($c[0]);
    }
  }
}

/**
 * Implements hook_workbench_moderation_access_alter().
 */
function know4pol_core_workbench_moderation_access_alter(&$access, $op, $node) {
  if ($op == 'view revisions') {
    $access = user_access('view revisions');
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function know4pol_core_entity_property_info_alter(&$info) {
  $info['node']['properties']['current-revision-author-username'] = array(
    'label' => t('Current revision author username'),
    'type' => 'text',
    'description' => t('The username of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-realname'] = array(
    'label' => t('Current revision author realname'),
    'type' => 'text',
    'description' => t('The realname of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-mail'] = array(
    'label' => t('Current revision author email'),
    'type' => 'text',
    'description' => t('The email of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
}

/**
 * Implements hook_tokens().
 */
function know4pol_core_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'entity' && $data['entity_type'] == 'node') {
    $node = $data['entity'];
    if (isset($node->revision_uid)) {
      $revision_author = user_load($node->revision_uid);
      $sanitize = !empty($options['sanitize']);
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'current-revision-author-username':
            $replacements[$original] = $sanitize ? check_plain($revision_author->name) : $revision_author->name;
            break;

          case 'current-revision-author-realname':
            $replacements[$original] = $sanitize ? check_plain($revision_author->realname) : $revision_author->realname;
            break;

          case 'current-revision-author-mail':
            $replacements[$original] = $sanitize ? check_plain($revision_author->mail) : $revision_author->mail;
            break;
        }
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#attributes']['class'][] = 'js-confirm-pop-up';
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'know4pol_core') . '/js/js_confirm_pop_up.js',
  );
}

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function know4pol_core_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  $targets['og_group_ref:label']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:etid']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary:label']['callback'] = '_know4pol_core_post_process_callback';
}

/**
 * Custom Entity reference callback for "og_group_ref"/"og_vocab" field mapping.
 *
 * When the callback is invoked, $target contains the name of the field the
 * user has decided to map to and $value contains the value of the feed item
 * element the user has picked as a source.
 *
 * @param FeedsSource $source
 *   A FeedsSource object.
 * @param object $entity
 *   The entity to map to.
 * @param string $target
 *   The target key on $entity to map to.
 * @param array $value
 *   The value to map. MUST be an array.
 */
function _know4pol_core_post_process_callback(FeedsSource $source, $entity, $target, array $value) {
  // First we define if the entity to change is a term or a node.
  if ($entity->feeds_item->entity_type == 'taxonomy_term') {
    $entity_id_key = 'tid';
  }
  else {
    $entity_id_key = 'nid';
  }
  // Then we get the status before processing the import.
  $entity_unchanged = entity_load_unchanged($entity->feeds_item->entity_type, $entity->$entity_id_key);
  // The customisation of the callback is only for the field "og_group_ref".
  $existing_og_group_ref = $entity_unchanged->og_group_ref;
  // Don't do anything if we weren't given any data.
  if (empty($value)) {
    return;
  }
  // Assume that the passed in value could really be any number of values.
  if (is_array($value)) {
    $values = $value;
  }
  else {
    $values = array($value);
  }
  // Determine the field we are matching against.
  if (strpos($target, ':') === FALSE) {
    $match_key = 'guid';
  }
  else {
    list($target, $match_key) = explode(':', $target, 2);
  }
  // Get some useful field information.
  $info = field_info_field($target);
  if ($match_key == 'label') {
    $handler = entityreference_get_selection_handler($info);
  }
  // Iterate over all values.
  $field = isset($entity->$target) ? $entity->$target : array();
  foreach ($values as $value) {
    // Only process if this value was set for this instance.
    if ($value) {
      switch ($match_key) {
        case 'guid':
        case 'url':
          // Fetch the entity ID resulting from the mapping table look-up.
          $entity_id = db_select('feeds_item', 'fi')
            ->fields('fi', array('entity_id'))
            ->condition($match_key, $value, '=')
            ->execute()
            ->fetchField();
          break;

        case 'etid':
          $entity_id = $value;
          break;

        case 'label':
          $options = $handler->getReferencableEntities($value, '=');
          if ($options) {
            // Change the logic for "og_vocabulary:label".
            if ($target == 'og_vocabulary') {
              foreach ($options as $key => $value) {
                $vocab = taxonomy_vocabulary_machine_name_load($key);
                $vocab_relation = og_vocab_relation_get($vocab->vid);
                if (!empty($vocab_relation)) {
                  $etids[] = array_keys($options[$key]);
                }
              }
              $og_vocabulary_term_ids = array_values($etids);
            }
            else {
              $options = reset($options);
              $etids = array_keys($options);
            }
          }
          // Use the first matching entity.
          $entity_id = reset($etids);
          break;
      }
      /*
       * Only add a reference to an existing entity ID if there exists a
       * mapping between it and the provided GUID.  In cases where no such
       * mapping exists (yet), don't do anything here.  There may be a mapping
       * defined later in the CSV file.  If so, and the user re-runs the import
       * (as a second pass), we can add this reference then.  (The "Update
       * existing nodes" option must be selected during the second pass.)
       */
      if ($og_vocabulary_term_ids) {
        foreach ($og_vocabulary_term_ids as $key => $value) {
          // Assign the target ID.
          $field[LANGUAGE_NONE][]['target_id'] = (string) $value[0];
        }
      }
      elseif ($entity_id) {
        // Assign the target ID.
        $field[LANGUAGE_NONE][]['target_id'] = (string) $entity_id;
      }
      else /* there is no $entity_id, no mapping */ {
        /*
         * Feeds stores a hash of every line imported from CSVs in order to
         * make the import process more efficient by ignoring lines it's
         * already seen.  We need to short-circuit this process in this case
         * because users may want to re-import the same line as an update later
         * when (and if) a map to a reference exists.  So in order to provide
         * this opportunity later, we need to destroy the hash.
         */
        unset($entity->feeds_item->hash);
        $source->log('entityreference', t('No existing entity found for entity @source_id entityreference to source entity @value', array('@source_id' => $entity->feeds_item->entity_id, '@value' => $value)));
      }
    }
    // Break out of the loop if this field is single-valued.
    if ($info['cardinality'] == 1) {
      break;
    }
  }

  // If the "og_group_ref" field has an old value,
  // then add the old and the new value.
  // Otherwise just add the field to the entity definition.
  if (!empty($existing_og_group_ref) && $target == 'og_group_ref') {
    $entity->og_group_ref = drupal_array_merge_deep($existing_og_group_ref, $field);
  }
  else {
    $entity->{$target} = $field;
  }
}

/**
 * Implements hook_feeds_presave().
 */
function know4pol_core_feeds_presave(FeedsSource $source, $entity, $item, $entity_id) {
  // For all imports, if the content is imported as published,
  // then we set the moderation to published as well.
  // This is not handled by Workbench_moderation module.
  if ($entity->status == "1") {
    $entity->workbench_moderation_state_new = workbench_moderation_state_published();
  }
  // Check first if we have any topics from Newsroom.
  if (!empty($entity->field_newsroom_topics[LANGUAGE_NONE])) {
    foreach ($entity->field_newsroom_topics[LANGUAGE_NONE] as $value) {
      $matched_term_in_tags = "";
      $matched_term_in_knowledge_service_og = "";
      // For each topic, first we load it,
      // in order to get its category and name.
      $entity_term = taxonomy_term_load($value['tid']);
      // If the category is "Knowledge4Policy Keywords".
      if ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge4Policy Keywords") {
        // Then we search its equivalent in "tags" vocabulary.
        $matched_term_in_tags = taxonomy_get_term_by_name($entity_term->name, 'tags');
        if (!empty($matched_term_in_tags)) {
          $matched_term_in_tags = array_shift($matched_term_in_tags);
          // Add the tag to the imported entity.
          $entity->field_tags[LANGUAGE_NONE][]['tid'] = $matched_term_in_tags->tid;
        }
      }
      // Else if the category is "Knowledge Service".
      elseif ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge Service") {
        // Then we search in "knowledge_centre" content type.
        // because it's a node reference.
        $query = new EntityFieldQuery();
        $matched_term_in_knowledge_service_og = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('type', 'knowledge_centre')
          ->propertyCondition('title', $entity_term->name)
          ->propertyCondition('status', 1)
          ->range(0, 1)
          ->execute();
        if (!empty($matched_term_in_knowledge_service_og)) {
          $matched_term_in_knowledge_service_og = array_shift($matched_term_in_knowledge_service_og['node']);
          // Add the related OG group to the imported entity.
          $entity->og_group_ref[LANGUAGE_NONE][]['target_id'] = $matched_term_in_knowledge_service_og->nid;
        }
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function know4pol_core_block_info() {
  $blocks = array();
  $blocks['apachesolr_freetext_search_block'] = array(
    'info' => t('Apache Solr Search Block'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function know4pol_core_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'apachesolr_freetext_search_block':
      if (arg(0) == 'search' && arg(1) == 'site') {
        $keys = urldecode(arg(2));
      }
      else {
        $keys = urldecode(arg(1));
      }
      $block_content = drupal_get_form('_know4pol_core_freetext_search_form', $keys);
      $block['content'] = drupal_render($block_content);
      break;
  }
  return $block;
}

/**
 * The free text search form for ApacheSolr pages.
 *
 * @param object $keys
 *   The search words/keys.
 */
function _know4pol_core_freetext_search_form($form, &$form_state, $keys = '') {
  $form = array();
  $form['#id'] = 'search-form';
  $form['#attributes']['class'][] = 'ecl-search-form';
  $form['#attributes']['class'][] = 'ecl-search-form--internal';
  $form['#attributes']['class'][] = 'ecl-u-mb-l';

  $form['basic'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('ecl-row', 'ecl-col', 'ecl-u-ma-none', 'ecl-u-pa-none'),
    ),
  );

  $form['basic']['keys'] = array(
    '#type' => 'textfield',
    '#default_value' => $keys,
    '#size' => 20,
    '#maxlength' => 255,
    '#attributes' => array('class' => array('ecl-text-input', 'ecl-search-form__textfield')),
  );

  $form['basic']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * The submit function for the free text search form for ApacheSolr pages.
 */
function _know4pol_core_freetext_search_form_submit(&$form, &$form_state) {
  // Should get the URL from the defined search pages.
  if (arg(0) == 'search' && arg(1) == 'site') {
    $redirect = 'search/site';
  }
  else {
    $redirect = arg(0);
  }
  $redirect_value = rawurlencode($form_state['values']['keys']);
  if (drupal_strlen($form_state['values']['keys'])) {
    $redirect .= '/' . $redirect_value;
  }

  $get = drupal_get_query_parameters();
  if (!empty($get)) {
    unset($get['q']);
    // Reset to first page.
    unset($get['page']);
  }
  $form_state['redirect'] = array($redirect, array('query' => $get));
}

/**
 * Implements hook_apachesolr_facet_items_alter().
 */
function know4pol_core_facet_items_alter(&$build, &$settings) {
  // Content type facet.
  switch ($settings->facet) {
    case "bundle":
      if (isset($build['newsroom_item'])) {
        $nr_facet_name = 'im_field_newsroom_item_type';
        $solr_pages = apachesolr_search_load_all_search_pages();

        // Split newsroom item in subtypes by getting the term facet.
        if ($adapter = _know4pol_ec_europa_get_solr_instance()) {
          $searcher = $adapter->getSearcher();
          $nr_type = $adapter->getFacet(facetapi_facet_load($nr_facet_name, $searcher));

          foreach ($nr_type->getBuild() as $key => $item) {
            // Get url for dedicated solR search page.
            foreach ($solr_pages as $solr_page) {
              if ($solr_page['label'] == $item['#markup'] || $solr_page['label'] == $item['#markup'] . 's') {
                $item['#path'] = $solr_page['search_path'];
                break;
              }
            }

            // Remove self since target page is already filtered.
            // Loop could be avoided if sure that self is always last.
            foreach ($item['#query']['f'] as $index => $value) {
              if ($value == $nr_facet_name . ':' . $item['#indexed_value']) {
                unset($item['#query']['f'][$index]);
                break;
              }
            }

            $build[$key] = $item;
          }
        }
        // Remove original filter anyway.
        unset($build['newsroom_item']);
      }
      break;
  }
}

/**
 * Implements hook_facetapi_sort_info().
 */
function know4pol_core_facetapi_sort_info() {
  $sorts = array();
  $sorts['ogvocab'] = array(
    'label' => t('OG vocab taxonomy'),
    'callback' => '_know4pol_core_facetapi_sort_ogvocab',
    'description' => t('Sort by taxonomy created into OG vocab'),
    'weight' => -50,
  );

  return $sorts;
}

/**
 * Parse term_id from facetapi indexed term and load term.
 *
 * @param string $term_info
 *   The indexed_term value from facetapi.
 *
 * @return object
 *   The loaded term by taxonomy_term_load().
 */
function _know4pol_core_facetapi_load_term($term_info) {
  // Parse tid from indexed values.
  if (preg_match('/\:([0-9]+)$/', $term_info, $r) != 1) {
    return NULL;
  }
  return taxonomy_term_load($r[1]);
}

/**
 * Facetapi sort, by vid of term.
 *
 * @see uasort()
 */
function _know4pol_core_facetapi_sort_ogvocab(array $a, array $b) {
  // Parse tid from indexed values.
  $a = _know4pol_core_facetapi_load_term($a['#indexed_value']);
  $b = _know4pol_core_facetapi_load_term($b['#indexed_value']);
  // Compare vid.
  return ($a->vid == $b->vid) ? 0 : ($a->vid > $b->vid) ? 1 : -1;
}

/**
 * Implements hook_facetapi_widgets().
 */
function know4pol_core_facetapi_widgets() {
  return array(
    'know4pol_core_ogvocab_list' => array(
      'handler' => array(
        'label' => t('OG vocab taxonomy'),
        'class' => 'Know4polCoreFacetapiWidgetOGVocab',
        'query types' => array('term'),
      ),
    ),
  );
}

/**
 * Implements hook_apachesolr_query_prepare().
 */
function know4pol_core_apachesolr_query_prepare($query) {
  $menu_item = menu_get_item();
  // Determine which apache solR page is viewed.
  switch ($menu_item['map'][0]) {
    case 'events':
    case 'news':
      $query->setSolrsort('field_newsroom_item_date', 'desc');
  }
}

/**
 * Implements hook_quicktabs_renderers().
 */
function know4pol_core_quicktabs_renderers() {
  $info = array();
  $path = drupal_get_path('module', 'know4pol_core') . '/plugins/quicktabs/';
  $info['ecl_tabs'] = array(
    'path' => $path,
    'handler' => array(
      'file' => 'Know4polCoreEclTabs.inc',
      'class' => 'Know4polCoreEclTabs',
    ),
  );
  return $info;
}

<?php

/**
 * @file
 * Code for the know4pol-core feature.
 */

/**
 * Implements hook_views_pre_build().
 */
function know4pol_core_views_pre_build(&$view) {
  // For all views, if they use the og_vocabulary.
  if (isset($view->argument['og_vocabulary_target_id'])) {
    $node = menu_get_item();
    $view->args[] = $node['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE][0]['target_id'];
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_user_admin_permissions_alter(&$form, &$form_state, $form_id) {
  $form['role_permissions'] = array(
    '#type' => 'value',
    '#value' => array(),
  );
  foreach ($form['role_names'] as $rid => $role) {
    if (strpos($rid, '#') !== FALSE) {
      continue;
    }
    $role_permissions = user_role_permissions(array($rid => $rid));
    $form['role_permissions']['#value'][$rid] = $role_permissions[$rid];
  }
  $form['#submit'][] = '_know4pol_core_form_user_admin_permissions_alter_submit';
}

/**
 * Log the changed user permissions.
 *
 * @param string $form
 *   The submitted form.
 * @param string $form_state
 *   The submitted form states.
 */
function _know4pol_core_form_user_admin_permissions_alter_submit(&$form, &$form_state) {
  global $user;
  foreach ($form['role_permissions']['#value'] as $rid => $role_permissions) {
    $data = array();
    foreach ($form_state['values'][$rid] as $permission => $value) {
      if (!isset($role_permissions[$permission])) {
        if ($value) {
          $data[$permission] = 1;
        }
      }
      elseif (!$role_permissions[$permission] && $value) {
        $data[$permission] = 1;
      }
      elseif ($role_permissions[$permission] && !$value) {
        $data[$permission] = 0;
      }
    }
    if (count($data)) {
      watchdog('permissions_changes',
        'The user "%user" changed the following permission(s) for the role "%role" to : %permissions',
        array(
          '%user' => $user->name,
          '%permissions' => print_r($data, TRUE),
          '%role' => $form['role_names'][$rid]['#markup'],
        ),
        WATCHDOG_NOTICE,
        NULL);
    }
  }
}

/**
 * Implements hook_permission().
 */
function know4pol_core_permission() {
  return array(
    'menu view unpublished' => array(
      'title' => t('View unpublished menu links'),
    ),
  );
}

/**
 * Implements hook_og_permission().
 */
function know4pol_core_og_permission() {
  return array(
    'menu OG view unpublished' => array(
      'title' => t('View OG unpublished menu links'),
    ),
    'assign publication to ks' => array(
      'title' => t('Assign publication to KS'),
      'description' => t('Assign publication to the current KS'),
    ),
  );
}

/**
 * Implements hook_query_TAG_alter().
 *
 * @see menu_tree_check_access()
 *   Contains the query being altered here.
 *   This is most likely the only query with tag node_access
 *   where the first condition is for the node.status column.
 */
function know4pol_core_query_node_access_alter(QueryAlterableInterface $query) {
  // We want to show unpulished menu links to some roles.
  // First we check if we're in an organic group
  // if yes, then we get the related group ID.
  $gid = "";
  $node = menu_get_object();
  // We check if we're in a content_type related to OG fields.
  if (isset($node->og_group_ref)) {
    // Then we check if the current page is the main page of the sub-site.
    if (isset($node->group_group[LANGUAGE_NONE][0]['value']) && ($node->group_group[LANGUAGE_NONE][0]['value'] == 1)) {
      $gid = $node->nid;
    }
    // Or if it's a sub-page of the sub-site.
    elseif (!empty($node->og_group_ref)) {
      $gid = $node->og_group_ref[LANGUAGE_NONE][0]['target_id'];
    }
  }
  // Then we check
  // if the current user has the drupal 'menu view unpublished' permission
  // Or the organic group one which is 'menu OG view unpublished'.
  if (user_access('menu view unpublished')
     || (!empty($gid) && (og_user_access('node', $gid, 'menu OG view unpublished')))
     ) {
    $c = &$query->conditions();
    // Remove the status condition if we suspect this query originates from
    // menu_tree_check_access().
    if (count($c) == 3 &&
      is_string($c[0]['field']) && $c[0]['field'] == 'n.status' &&
      is_string($c[1]['field']) && $c[1]['field'] == 'n.nid' && $c[1]['operator'] == 'IN') {
      unset($c[0]);
    }
  }
}

/**
 * Implements hook_workbench_moderation_access_alter().
 */
function know4pol_core_workbench_moderation_access_alter(&$access, $op, $node) {
  if ($op == 'view revisions') {
    $access = user_access('view revisions');
  }
}

/**
 * Implements Implements hook_token_info().
 */
function know4pol_core_token_info() {
  $site['know4pol_og_group_ref'] = array(
    'name' => t('List of knowledge services'),
    'description' => t('List of knowledge services seperated by plus sign)'),
  );

  return array(
    'tokens' => array(
      'site' => $site,
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function know4pol_core_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'site') {
    foreach ($tokens as $name => $original) {
      if ($name == 'know4pol_og_group_ref') {
        $gids = array();
        $node = menu_get_object();
        if (!empty($node->og_group_ref)) {
          // We are editing a node.
          foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
            $gids[] = $gid['target_id'];
          }
        }
        else {
          // We are in a "Add content" page.
          $node = menu_get_item();
          $url_parameters = drupal_get_query_parameters();
          if (isset($url_parameters['og_group_ref']) && !empty($url_parameters['og_group_ref'])) {
            $gids[] = $url_parameters['og_group_ref'];
          }
        }
        $replacements[$original] = implode('+', $gids);
        break;
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#attributes']['class'][] = 'js-confirm-pop-up';
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'know4pol_core') . '/js/js_confirm_pop_up.js',
  );
}

/**
 * Implements hook_og_vocab_get_accessible_vocabs_alter().
 */
function know4pol_core_og_vocab_get_accessible_vocabs_alter(&$result) {
  $gids = array();
  $node = menu_get_object();
  if (!empty($node->og_group_ref)) {
    foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
      $gids[] = $gid['target_id'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node->type, $gids);
  }
  else {
    // We are in a "Add content" page.
    $node = menu_get_item();
    $url_parameters = drupal_get_query_parameters();
    if (!empty($url_parameters)) {
      $gids[] = $url_parameters['og_group_ref'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node['page_arguments'][0], $gids);
  }
}

/**
 * Get all the vocabs a user may access.
 *
 * This will include the global vocabualries (i.e. ones that aren't associated
 * with a group), and the ones that are associated with a group the user is a
 * member.
 *
 * @param string $bundle
 *   The entity type.
 * @param array $gids
 *   The group ids.
 *
 * @return array
 *   An array with the vocabulary IDs or an empty array if no vocabulary
 *   was found.
 */
function _know4pol_core_get_accessible_vocabs($bundle, array $gids) {
  $vids = array();
  if ($gids) {
    $query = db_select('og_vocab', 'ogv');
    $query->join('og_vocab_relation', 'ovr', 'ogv.vid = ovr.vid');
    $query->fields('ogv', array('vid'))
      ->condition('gid', $gids, 'IN')
      ->condition('bundle', $bundle);
    $vids = $query->execute()->fetchAllAssoc('vid');
  }
  return $vids;
}

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function know4pol_core_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  $targets['og_group_ref:label']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:etid']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary:label']['callback'] = '_know4pol_core_post_process_callback';
  if ($entity_type == 'node') {
    $content_type_og_vocabularies = _know4pol_core_get_og_vocabularies_by_content_type($bundle_name);
    foreach ($content_type_og_vocabularies as $vocab) {
      $targets['og_vocabulary:' . $vocab->machine_name]['name'] = 'og_vocabulary:' . $vocab->name;
      $targets['og_vocabulary:' . $vocab->machine_name]['callback'] = '_know4pol_core_post_process_callback';
      $targets['og_vocabulary:' . $vocab->machine_name]['summary_callbacks'] = array('taxonomy_feeds_summary_callback');
      $targets['og_vocabulary:' . $vocab->machine_name]['form_callbacks'] = array('taxonomy_feeds_form_callback');
    }
  }
}

/**
 * Get all Vocabularies related to a group.
 */
function _know4pol_core_get_og_vocabularies_by_content_type($bundle_name) {
  $query = db_select('og_vocab', 'ov');
  $query->join('taxonomy_vocabulary', 'tv', 'tv.vid = ov.vid');
  $query->fields('ov', array('vid'))
    ->fields('tv', array('name', 'machine_name'))
    ->condition('bundle', $bundle_name);
  $result = $query->execute()->fetchAll();
  return $result;
}

/**
 * Custom Entity reference callback for "og_group_ref"/"og_vocab" field mapping.
 *
 * When the callback is invoked, $target contains the name of the field the
 * user has decided to map to and $value contains the value of the feed item
 * element the user has picked as a source.
 *
 * @param FeedsSource $source
 *   A FeedsSource object.
 * @param object $entity
 *   The entity to map to.
 * @param string $target
 *   The target key on $entity to map to.
 * @param array $value
 *   The value to map. MUST be an array.
 */
function _know4pol_core_post_process_callback(FeedsSource $source, $entity, $target, array $value) {
  // First we define if the entity to change is a term or a node.
  if ($entity->feeds_item->entity_type == 'taxonomy_term') {
    $entity_id_key = 'tid';
  }
  else {
    $entity_id_key = 'nid';
  }
  // Then we get the status before processing the import.
  $entity_unchanged = entity_load_unchanged($entity->feeds_item->entity_type, $entity->$entity_id_key);
  // The customisation of the callback is only for the field "og_group_ref".
  $existing_og_group_ref = $entity_unchanged->og_group_ref;
  // Don't do anything if we weren't given any data.
  if (empty($value)) {
    return;
  }
  // Assume that the passed in value could really be any number of values.
  if (is_array($value)) {
    $values = $value;
  }
  else {
    $values = array($value);
  }
  // Determine the field we are matching against.
  if (strpos($target, ':') === FALSE) {
    $match_key = 'guid';
  }
  else {
    list($target, $match_key) = explode(':', $target, 2);
  }
  // Get some useful field information.
  $info = field_info_field($target);
  if ($match_key == 'label') {
    $handler = entityreference_get_selection_handler($info);
  }
  // Iterate over all values.
  $field = isset($entity->$target) ? $entity->$target : array();
  foreach ($values as $value) {
    // Only process if this value was set for this instance.
    if ($value) {
      switch ($match_key) {
        case 'guid':
        case 'url':
          // Fetch the entity ID resulting from the mapping table look-up.
          $entity_id = db_select('feeds_item', 'fi')
            ->fields('fi', array('entity_id'))
            ->condition($match_key, $value, '=')
            ->execute()
            ->fetchField();
          break;

        case 'etid':
          $entity_id = $value;
          break;

        case 'label':
          $options = $handler->getReferencableEntities($value, '=');
          if ($options) {
            // Change the logic for "og_vocabulary:label".
            if ($target == 'og_vocabulary') {
              foreach ($options as $key => $value) {
                $vocab = taxonomy_vocabulary_machine_name_load($key);
                $vocab_relation = og_vocab_relation_get($vocab->vid);
                if (!empty($vocab_relation)) {
                  $etids[] = array_keys($options[$key]);
                }
              }
              $og_vocabulary_term_ids = array_values($etids);
            }
            else {
              $options = reset($options);
              $etids = array_keys($options);
            }
          }
          // Use the first matching entity.
          $entity_id = reset($etids);
          break;

        default:
          // This is to assign items to a specific og vocabulary.
          if ($target == 'og_vocabulary') {
            // Get some useful field information.
            $info = field_info_field($target);
            $handler = entityreference_get_selection_handler($info);
            $options = $handler->getReferencableEntities($value, '=');
            if (!empty($options[$match_key])) {
              $etid = array_keys($options[$match_key]);
            }
            $entity_id = "";
            if (!empty($etid)) {
              $entity_id = reset($etid);
            }
          }
          break;
      }
      /*
       * Only add a reference to an existing entity ID if there exists a
       * mapping between it and the provided GUID.  In cases where no such
       * mapping exists (yet), don't do anything here.  There may be a mapping
       * defined later in the CSV file.  If so, and the user re-runs the import
       * (as a second pass), we can add this reference then.  (The "Update
       * existing nodes" option must be selected during the second pass.)
       */
      if (isset($og_vocabulary_term_ids)) {
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        foreach ($og_vocabulary_term_ids as $key => $value) {
          // Assign the target ID.
          if (!in_array($value[0], $existing_target_ids)) {
            $field[LANGUAGE_NONE][]['target_id'] = (string) $value[0];
          }
        }
      }
      elseif ($entity_id) {
        // Assign the target ID.
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        if (!in_array($entity_id, $existing_target_ids)) {
          $field[LANGUAGE_NONE][]['target_id'] = (string) $entity_id;
        }
      }
      else /* there is no $entity_id, no mapping */ {
        /*
         * Feeds stores a hash of every line imported from CSVs in order to
         * make the import process more efficient by ignoring lines it's
         * already seen.  We need to short-circuit this process in this case
         * because users may want to re-import the same line as an update later
         * when (and if) a map to a reference exists.  So in order to provide
         * this opportunity later, we need to destroy the hash.
         */
        unset($entity->feeds_item->hash);
        $source->log('entityreference', t('No existing entity found for entity @source_id entityreference to source entity @value', array('@source_id' => $entity->feeds_item->entity_id, '@value' => $value)));
      }
    }
    // Break out of the loop if this field is single-valued.
    if ($info['cardinality'] == 1) {
      break;
    }
  }

  // If the "og_group_ref" field has an old value,
  // then add the old and the new value.
  // Otherwise just add the field to the entity definition.
  if (!empty($existing_og_group_ref) && $target == 'og_group_ref') {
    $entity->og_group_ref = drupal_array_merge_deep($existing_og_group_ref, $field);
  }
  else {
    $entity->{$target} = $field;
  }
}

/**
 * Implements hook_feeds_presave().
 */
function know4pol_core_feeds_presave(FeedsSource $source, $entity, $item, $entity_id) {
  // For all imports, if the content is imported as published,
  // then we set the moderation to published as well.
  // This is not handled by Workbench_moderation module.
  if ($entity->status == "1") {
    $entity->workbench_moderation_state_new = workbench_moderation_state_published();
  }
  // Check first if we have any topics from Newsroom.
  if (!empty($entity->field_newsroom_topics[LANGUAGE_NONE])) {
    foreach ($entity->field_newsroom_topics[LANGUAGE_NONE] as $value) {
      $matched_term_in_tags = "";
      $matched_term_in_knowledge_service_og = "";
      // For each topic, first we load it,
      // in order to get its category and name.
      $entity_term = taxonomy_term_load($value['tid']);
      // If the category is "Knowledge4Policy Keywords".
      if ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge4Policy Keywords") {
        // Then we search its equivalent in "tags" vocabulary.
        $matched_term_in_tags = taxonomy_get_term_by_name($entity_term->name, 'tags');
        if (!empty($matched_term_in_tags)) {
          $matched_term_in_tags = array_shift($matched_term_in_tags);
          // Add the tag to the imported entity.
          $entity->field_tags[LANGUAGE_NONE][]['tid'] = $matched_term_in_tags->tid;
        }
      }
      // Else if the category is "Knowledge Service".
      elseif ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge Service") {
        // Then we search in "knowledge_centre" content type.
        // because it's a node reference.
        $query = new EntityFieldQuery();
        $matched_term_in_knowledge_service_og = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('type', 'knowledge_centre')
          ->propertyCondition('title', $entity_term->name)
          ->propertyCondition('status', 1)
          ->range(0, 1)
          ->execute();
        if (!empty($matched_term_in_knowledge_service_og)) {
          $matched_term_in_knowledge_service_og = array_shift($matched_term_in_knowledge_service_og['node']);
          // Add the related OG group to the imported entity.
          $entity->og_group_ref[LANGUAGE_NONE][]['target_id'] = $matched_term_in_knowledge_service_og->nid;
        }
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function know4pol_core_block_info() {
  $blocks = array();
  $blocks['know4pol_ks_latest_content'] = array(
    'info' => t('Know4pol KS latest content block'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['know4pol_ks_admin_menu'] = array(
    'info' => t('Know4pol KS admin block'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function know4pol_core_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'know4pol_ks_latest_content':
      $block['content'] = '<ul class="ecl-listing ecl-listing--three-columns">';
      $item = menu_get_item();
      if (!empty($item['page_arguments'][0]->nid)) {
        // Block 1 : latest news.
        $view1 = views_get_view_result('ks_latest_content', 'latest_news', $item['page_arguments'][0]->nid);
        if (count($view1)) {
          $block_latest_news = views_embed_view('ks_latest_content', 'latest_news', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Latest News</h3>' . $block_latest_news . '</div></li>';
        }
        // Block 2 : next events.
        $view2 = views_get_view_result('ks_latest_content', 'next_events', $item['page_arguments'][0]->nid);
        if (count($view2)) {
          $block_next_events = views_embed_view('ks_latest_content', 'next_events', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Next Events</h3>' . $block_next_events . '</div></li>';
        }
        // Block 3 : latest resources.
        $view3 = views_get_view_result('ks_latest_content', 'latest_resources', $item['page_arguments'][0]->nid);
        if (count($view3)) {
          $block_latest_resources = views_embed_view('ks_latest_content', 'latest_resources', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Latest Resources</h3>' . $block_latest_resources . '</div></li>';
        }
        $block['content'] .= '</ul>';
      }
      break;

    case 'know4pol_ks_admin_menu':
      $block['content'] = _know4pol_core_theme_ks_admin_menu(_know4pol_core_get_ks_admin_menu('menu-ks-admin-menu'));
      break;
  }
  return $block;
}

/**
 * Prepares menu array for theming.
 *
 * @param string $menu_name
 *   Machine name of KS admin menu.
 *
 * @return array
 *   Generated menu array.
 */
function _know4pol_core_get_ks_admin_menu($menu_name) {
  $loaded_menu = menu_tree_page_data($menu_name);
  $output = array();
  if (!empty($loaded_menu)) {
    foreach ($loaded_menu as $loaded_menu_parent_item) {
      $child_items = $loaded_menu_parent_item['below'];
      if (!empty($child_items)) {
        foreach ($child_items as $child_item) {
          $attributes = array(
            'attributes' =>
              array(
                'class' =>
                  array(
                    'ecl-link',
                    'ecl-link--standalone',
                    'ecl-link-block__link',
                  ),
              ),
          );
          $links[] = l($child_item['link']['link_title'], $child_item['link']['href'], $attributes);
        }
      }
      else {
        $links = '';
      }
      $output[$loaded_menu_parent_item['link']['link_title']]['title'] = $loaded_menu_parent_item['link']['link_title'];
      $output[$loaded_menu_parent_item['link']['link_title']]['link'] = '<a class="ecl-button ecl-button--primary" href="' . url($loaded_menu_parent_item['link']['href']) . '">' . $loaded_menu_parent_item['link']['link_title'] . '</a>';
      $output[$loaded_menu_parent_item['link']['link_title']]['links'] = $links;
      unset($links);
    }
  }
  return $output;
}

/**
 * Wraps links into set of buttons and dropdowns.
 *
 * @param array $menuarray
 *   Generated menu array.
 *
 * @return string
 *   Generated menu.
 */
function _know4pol_core_theme_ks_admin_menu(array $menuarray) {
  $output = "";
  foreach ($menuarray as $parent) {
    if ($parent['links']) {
      $output = '<div class="element">
                  <div class="ecl-dropdown">
                    <button class="ecl-button ecl-button--default ecl-expandable__button"
                            aria-controls="' . $parent['title'] . '-button-dropdown" aria-expanded="false"
                            id="' . $parent['title'] . '-expandable-button"
                            type="button">' . $parent['title'] . '
                    </button>
                  <div class="ecl-link-block ecl-dropdown__body" id="' . $parent['title'] . '-button-dropdown" aria-labelledby="' . $parent['title'] . '-expandable-button" aria-hidden="true">
                  <ul class="ecl-link-block__list">';
      foreach ($parent['links'] as $link) {
        $output .= '<li class="ecl-link-block__item">' . $link . '</li>';
      }
      $output .= '</ul></div></div></div>';
    }
    else {
      $output .= '<p>' . $parent['link'] . '</p>';
    }
  }
  return $output;
}

/**
 * Implements hook_menu_alter().
 */
function know4pol_core_menu_alter(&$items) {
  $items['node/add']['access callback'] = '_know4pol_core_node_add_access';
  $items['admin/workbench/create']['access callback'] = '_know4pol_core_node_add_access';
}

/**
 * Access callback: function for add content menu item.
 *
 * @return bool
 *   TRUE if the user has add permission, otherwise FALSE.
 *
 * @see _node_add_access()
 */
function _know4pol_core_node_add_access() {
  if (user_access('administer content types')) {
    return _node_add_access();
  }
  return FALSE;
}

/**
 * Implements hook_action_info().
 */
function know4pol_core_action_info() {
  return array(
    '_know4pol_core_assign_ks_action' => array(
      'type' => 'entity',
      'label' => t('Assign publication to current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    '_know4pol_core_unassign_ks_action' => array(
      'type' => 'entity',
      'label' => t('Unassign publication from current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_assign_ks_action($entity, array $context) {
  $target_group_id = $context['view_info']['arguments'][0];
  $next = count($entity->og_group_ref[LANGUAGE_NONE]);
  $entity->og_group_ref[LANGUAGE_NONE][$next]['target_id'] = $target_group_id;
  node_save($entity);
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_unassign_ks_action($entity, array $context) {
  $target_group_id = $context['view_info']['arguments'][0];
  $og_array = $entity->og_group_ref[LANGUAGE_NONE];
  foreach ($og_array as $key => $value) {
    if ($value['target_id'] == $target_group_id) {
      unset($og_array[$key]);
    }
  }
  $entity->og_group_ref[LANGUAGE_NONE] = array_values($og_array);
  node_save($entity);
}

/**
 * Implements hook_field_display_alter().
 */
function know4pol_core_field_display_alter(&$display, $context) {
  // Add the <p> tag to the field_ne_body summary, if not available.
  if (isset($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
  // Add the <p> tag to the body summary, if not available.
  if (isset($context['entity']->body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
}

/**
 * Implements hook_preprocess_html().
 */
function know4pol_core_preprocess_html(&$variables) {
  global $theme;
  if ($theme == 'seven') {
    drupal_add_css(drupal_get_path('module', 'know4pol_core') . '/css/know4pol_core_admin.css');
  }
}

/**
 * Implements hook_views_query_alter().
 */
function know4pol_core_views_query_alter(&$view, &$query) {
  if ($view->name == 'organisation_related_knowledge_services') {
    // Get the nid.
    if ($node = menu_get_object()) {
      $nid = $node->nid;
    }
    $dbquery = db_select('og_membership', 'om');
    $dbquery->distinct();
    $dbquery->fields('om', array('gid'));
    $dbquery->condition('etid', $nid);
    $result = $dbquery->execute()->fetchAll();
    foreach ($result as $row) {
      $tids[] = $row->gid;
    }
    $query->add_where(1, 'node.nid', $tids, 'IN');
  }
}

/**
 * Implements hook_webform_select_options_info().
 */
function know4pol_core_webform_select_options_info() {
  $items = array();
  $items['states'] = array(
    'title' => t('Knowledge services'),
    'options callback' => '_know4pol_core_webform_options_knowledge_services',
  );
  return $items;
}

/**
 * Get the list of all published KS names.
 *
 * @return array
 *   List of all published Knowledge services.
 */
function _know4pol_core_webform_options_knowledge_services() {
  $query = db_select('node', 'n')
    ->fields('n', array('nid', 'title'))
    ->condition('type', 'knowledge_centre')
    ->condition('status', 1);
  $knowledge_services = $query->execute()->fetchAllAssoc('nid');
  $ks_list = array();
  foreach ($knowledge_services as $nid => $knowledge_service) {
    $ks_list[$nid] = $knowledge_service->title;
  }
  return $ks_list;
}

/**
 * Implements hook_ds_fields_info().
 */
function know4pol_core_ds_fields_info($entity_type) {
  $fields = array();

  $fields['node']['ks_name_topic_specific_taxonomies'] = array(
    'title' => t('Knowledge service | Topic | Specific keywords'),
    'field_type' => DS_FIELD_TYPE_FUNCTION,
    'function' => '_know4pol_core_render_ks_name_topic_specific_taxonomies',
  );

  return $fields;
}

/**
 * Helper function that creates a custom ds field.
 *
 * @param array $field
 *   All information on the field and its parent entity.
 *
 * @return string
 *   Space, to have it render.
 */
function _know4pol_core_render_ks_name_topic_specific_taxonomies(array $field) {
  $content = "";
  $menu = menu_get_item();

  // Let's define the three fields to be shown.
  $knowledge_services_topics = $menu['page_arguments'][0]->field_ks_related_topics[LANGUAGE_NONE];
  $knowledge_services_specific_keywords = $menu['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE];
  $knowledge_services = $menu['page_arguments'][0]->og_group_ref[LANGUAGE_NONE];

  // Let's filter topics/specific keywords by knowledge service.
  foreach ($knowledge_services as $knowledge_service) {
    // Go to line for the new knowledege services.
    if ($content != "") {
      $content .= '<br>';
    }
    $content .= _know4pol_core_get_topic_keywords_fields_by_ks($knowledge_services_topics, $knowledge_services_specific_keywords, $knowledge_service);
  }
  return $content;
}

/**
 * Filter topics/specific keywords by knowledge service.
 *
 * @param array $knowledge_services_topics
 *   A list of topics.
 * @param array $knowledge_services_specific_keywords
 *   A list of specific keywords.
 * @param array $knowledge_service
 *   A knowledge service.
 *
 * @return string
 *   The rendered content.
 */
function _know4pol_core_get_topic_keywords_fields_by_ks(array $knowledge_services_topics, array $knowledge_services_specific_keywords, array $knowledge_service) {
  $content = "";
  // First add the name of the knowledge service.
  $ks_name = $knowledge_service['label'];
  $ks_url_alias = drupal_lookup_path('alias', $knowledge_service['url']);
  $content .= l($ks_name, $ks_url_alias, array('attributes' => array('class' => array('ecl-tag__item', 'know4pol-main-resource-meta-link'))));

  // Second create the list of topics per knowledge service.
  $ks_topics_content = "";
  foreach ($knowledge_services_topics as $knowledge_services_topic) {
    if ($knowledge_services_topic['object']['node']->og_group_ref[LANGUAGE_NONE][0]['target_id'] == $knowledge_service['target_id']) {
      $ks_topics_content .= _know4pol_core_create_topic_link($knowledge_services_topic);
    }
  }
  if ($ks_topics_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_topics_content);
  }

  // Third add the list of specific keywords per KS.
  // First get the default vocabulary from the knowledge service content type.
  $ks_keyword_content = "";
  $knowledge_service_node = node_load($knowledge_service['target_id']);
  $main_ks_keywords_vocab_id = $knowledge_service_node->field_the_main_ks_keywords_vocab[LANGUAGE_NONE][0]['target_id'];
  $ks_terms = array_keys(entity_load('taxonomy_term', FALSE, array('vid' => $main_ks_keywords_vocab_id)));
  foreach ($knowledge_services_specific_keywords as $ks_keyword) {
    if (in_array($ks_keyword['target_id'], $ks_terms)) {
      $ks_keyword_content .= _know4pol_core_create_keyword_content_link($ks_keyword, $knowledge_service);
    }
  }
  if ($ks_keyword_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_keyword_content);
  }
  return $content;
}

/**
 * Create the topic link.
 *
 * @param array $knowledge_services_topic
 *   A knowledge service topic.
 */
function _know4pol_core_create_topic_link(array $knowledge_services_topic) {
  $ks_topics_content_title = $knowledge_services_topic['object']['node']->title;
  $ks_topics_content_path = $knowledge_services_topic['object']['node']->path['alias'];
  return l($ks_topics_content_title, $ks_topics_content_path, array('attributes' => array('class' => array('ecl-tag__item'))));
}

/**
 * Create the keyword link.
 *
 * @param array $ks_keyword
 *   A Knowledge service keyword.
 * @param array $knowledge_service
 *   The related knowledge service.
 */
function _know4pol_core_create_keyword_content_link(array $ks_keyword, array $knowledge_service) {
  global $base_url;
  $ks_keyword_content_title = $ks_keyword['title'];
  $ks_keyword_content_path = $base_url . '/search/site';
  return l($ks_keyword_content_title, $ks_keyword_content_path,
                                array(
                                  'attributes' => array('class' => array('ecl-tag__item')),
                                  'query' => array('f[0]' => 'sm_og_vocabulary:' . $ks_keyword['facet_id'], 'f[1]' => 'sm_og_group_ref:node:' . $knowledge_service['target_id']),
                                ));
}

/**
 * Add "|" sign before the given text.
 *
 * @param string $content
 *   The content to be changed.
 */
function _know4pol_core_add_seperation_bar($content) {
  return '|' . $content;
}

<?php

/**
 * @file
 * Code for the know4pol-core feature.
 */

/**
 * Implements hook_field_default_field_instances_alter().
 */
function know4pol_core_field_default_field_instances_alter(&$fields) {
  // Event content type.
  if (!empty($fields['node-page-field_ne_body'])) {
    $fields['node-page-field_ne_body']['settings']['entity_translation_sync'] = FALSE;
  }
}

/**
 * Implements hook_views_pre_build().
 */
function know4pol_core_views_pre_build(&$view) {
  // For all views, if they use the og_vocabulary.
  if (isset($view->argument['og_vocabulary_target_id'])) {
    $node = menu_get_item();
    $view->args[] = $node['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE][0]['target_id'];
  }
}

/**
 * Implements hook_views_pre_render().
 */
function know4pol_core_views_pre_render(&$view) {
  // For the organisation_related_knowledge_services view,
  // we would replace the description field by
  // the organisation custom KS descripion field,if availaible.
  if ($view->name == "organisation_related_knowledge_services") {
    $node = menu_get_item();
    if (isset($node['page_arguments'][0]->field_org_ks_specific_desc[LANGUAGE_NONE])) {
      foreach ($node['page_arguments'][0]->field_org_ks_specific_desc[LANGUAGE_NONE] as $item) {
        $node_field_collection = field_collection_item_load($item['value'], FALSE);
        $ks_desc_nid = $node_field_collection->field_org_ks_desc_related_ks[LANGUAGE_NONE][0]['target_id'];
        $ks_desc_new_description = $node_field_collection->field_org_ks_desc_specific_desc[LANGUAGE_NONE][0]['value'];
        if (isset($view->result) && !empty($view->result) && !empty($ks_desc_new_description)) {
          foreach ($view->result as $key => $value) {
            if ($value->nid == $ks_desc_nid) {
              $view->result[$key]->field_field_short_description[0]['rendered']['#markup'] =
              $view->result[$key]->field_field_short_description[0]['raw']['value'] =
              $view->result[$key]->field_field_short_description[0]['raw']['safe_value'] = $ks_desc_new_description;
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_user_admin_permissions_alter(&$form, &$form_state, $form_id) {
  $form['role_permissions'] = array(
    '#type' => 'value',
    '#value' => array(),
  );
  foreach ($form['role_names'] as $rid => $role) {
    if (strpos($rid, '#') !== FALSE) {
      continue;
    }
    $role_permissions = user_role_permissions(array($rid => $rid));
    $form['role_permissions']['#value'][$rid] = $role_permissions[$rid];
  }
  $form['#submit'][] = '_know4pol_core_form_user_admin_permissions_alter_submit';
}

/**
 * Log the changed user permissions.
 *
 * @param string $form
 *   The submitted form.
 * @param string $form_state
 *   The submitted form states.
 */
function _know4pol_core_form_user_admin_permissions_alter_submit(&$form, &$form_state) {
  global $user;
  foreach ($form['role_permissions']['#value'] as $rid => $role_permissions) {
    $data = array();
    foreach ($form_state['values'][$rid] as $permission => $value) {
      if (!isset($role_permissions[$permission])) {
        if ($value) {
          $data[$permission] = 1;
        }
      }
      elseif (!$role_permissions[$permission] && $value) {
        $data[$permission] = 1;
      }
      elseif ($role_permissions[$permission] && !$value) {
        $data[$permission] = 0;
      }
    }
    if (count($data)) {
      watchdog('permissions_changes',
        'The user "%user" changed the following permission(s) for the role "%role" to : %permissions',
        array(
          '%user' => $user->name,
          '%permissions' => print_r($data, TRUE),
          '%role' => $form['role_names'][$rid]['#markup'],
        ),
        WATCHDOG_NOTICE,
        NULL);
    }
  }
}

/**
 * Implements hook_og_permission().
 */
function know4pol_core_og_permission() {
  return array(
    'view manage KS content section' => array(
      'title' => t('View "manage KS content" in admin toolbar'),
    ),
    'unpublish ks content' => array(
      'title' => t('Unpublish KS content'),
      'description' => t('Unpublish KS content'),
    ),
  );
}

/**
 * Implements hook_workbench_moderation_access_alter().
 */
function know4pol_core_workbench_moderation_access_alter(&$access, $op, $node) {
  if ($op == 'view revisions') {
    $access = user_access('view revisions');
  }
}

/**
 * Implements Implements hook_token_info().
 */
function know4pol_core_token_info() {
  $site['know4pol_og_group_ref'] = array(
    'name' => t('List of knowledge services'),
    'description' => t('List of knowledge services seperated by plus sign)'),
  );

  return array(
    'tokens' => array(
      'site' => $site,
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function know4pol_core_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  if ($type == 'site') {
    foreach ($tokens as $name => $original) {
      if ($name == 'know4pol_og_group_ref') {
        $gids = array();
        $node = menu_get_object();
        if (!empty($node->og_group_ref)) {
          // We are editing a node.
          foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
            $gids[] = $gid['target_id'];
          }
        }
        else {
          // We are in a "Add content" page.
          $node = menu_get_item();
          $url_parameters = drupal_get_query_parameters();
          if (isset($url_parameters['og_group_ref']) && !empty($url_parameters['og_group_ref'])) {
            $gids[] = $url_parameters['og_group_ref'];
          }
        }
        $replacements[$original] = implode('+', $gids);
        break;
      }
    }
  }

  if ($type == 'entity' && $data['entity_type'] == 'node') {
    $node = $data['entity'];
    if (isset($node->revision_uid)) {
      $revision_author = user_load($node->revision_uid);
      $sanitize = !empty($options['sanitize']);
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'current-revision-author-username':
            $replacements[$original] = $sanitize ? check_plain($revision_author->name) : $revision_author->name;
            break;

          case 'current-revision-author-realname':
            $replacements[$original] = $sanitize ? check_plain($revision_author->realname) : $revision_author->realname;
            break;

          case 'current-revision-author-mail':
            $replacements[$original] = $sanitize ? check_plain($revision_author->mail) : $revision_author->mail;
            break;
        }
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Disable all fields if it's coming from Pubsy.
  if ($form['#node']->type == 'publication' && $form['#node']->uid == '1') {
    $form['title']['#disabled'] = TRUE;
    $form['field_pub_image']['#disabled'] = TRUE;
    $form['body']['#disabled'] = TRUE;
    $form['field_pub_links']['#disabled'] = TRUE;
    $form['field_pub_files_ref']['#disabled'] = TRUE;
    $form['field_last_update']['#disabled'] = TRUE;
    $form['field_pub_type']['#disabled'] = TRUE;
    $form['field_related_organisations']['#disabled'] = TRUE;
    $form['field_project_activity']['#disabled'] = TRUE;
    $form['field_pub_dc_date_accessioned']['#disabled'] = TRUE;
    $form['field_pub_dc_date_available']['#disabled'] = TRUE;
    $form['field_pub_dc_date_created']['#disabled'] = TRUE;
    $form['field_pub_dc_date_submitted']['#disabled'] = TRUE;
    $form['field_pub_dc_date_issued']['#disabled'] = TRUE;
    $form['field_pub_dc_rel_ispartofseries']['#disabled'] = TRUE;
    $form['field_pub_pubsy_identities']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_doi']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_isbn']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_issn']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_eur']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_opoce']['#disabled'] = TRUE;
    $form['field_pub_dc_identifier_uri']['#disabled'] = TRUE;
    $form['field_pub_dc_publisher']['#disabled'] = TRUE;
    $form['field_pub_dc_contributor_authors']['#disabled'] = TRUE;
    $form['field_pub_dc_descrip_abstract']['#disabled'] = TRUE;
    $form['field_pub_dc_descrip_sponsorship']['#disabled'] = TRUE;
    $form['field_pub_dc_format_medium']['#disabled'] = TRUE;
    $form['field_pub_dc_language']['#disabled'] = TRUE;
    $form['field_pub_dc_type']['#disabled'] = TRUE;
  }

  $form['actions']['unpublish'] = array(
    '#type' => 'submit',
    '#value' => 'Unpublish',
    '#submit' => array('_know4pol_core_unpublish_submit'),
    '#access' => _know4pol_core_unpublish_access(),
    '#weight' => 100,
  );
  $form['#attributes']['class'][] = 'js-confirm-pop-up';
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'know4pol_core') . '/js/js_confirm_pop_up.js',
  );
}

/**
 * The callback function for the unpublish button.
 */
function _know4pol_core_unpublish_submit($form, &$form_state) {
  if ($form_state['values']['unpublish'] == 'Unpublish') {
    drupal_goto('node/' . $form['nid']['#value'] . '/moderation/' . $form['vid']['#value'] . '/unpublish');
  }
}

/**
 * The access function for the unpublish button.
 */
function _know4pol_core_unpublish_access($node = array()) {
  global $user;
  if (empty($node)) {
    $node = menu_get_object();
  }
  // We should fisr make sure that we're editing
  // and not creating a new content.
  if (!empty($node->og_group_ref[LANGUAGE_NONE])) {
    // If admin/webmaster, we bypass the right.
    if (in_array('administrator', array_values($user->roles)) || in_array('webmaster', array_values($user->roles))) {
      return TRUE;
    }
    else {
      // We check if the user has the prmission
      // in any of the assigned knowledge services.
      $gids = $node->og_group_ref[LANGUAGE_NONE];
      foreach ($gids as $gid) {
        $access = og_user_access('node', $gid['target_id'], 'unpublish ks content');
        if ($access == TRUE) {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_og_vocab_get_accessible_vocabs_alter().
 */
function know4pol_core_og_vocab_get_accessible_vocabs_alter(&$result) {
  $gids = array();
  $node = menu_get_object();
  if (!empty($node->og_group_ref)) {
    foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
      $gids[] = $gid['target_id'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node->type, $gids);
  }
  else {
    // We are in a "Add content" page.
    $node = menu_get_item();
    $url_parameters = drupal_get_query_parameters();
    if (!empty($url_parameters)) {
      $gids[] = $url_parameters['og_group_ref'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node['page_arguments'][0], $gids);
  }
}

/**
 * Get all the vocabs a user may access.
 *
 * This will include the global vocabualries (i.e. ones that aren't associated
 * with a group), and the ones that are associated with a group the user is a
 * member.
 *
 * @param string $bundle
 *   The entity type.
 * @param array $gids
 *   The group ids.
 *
 * @return array
 *   An array with the vocabulary IDs or an empty array if no vocabulary
 *   was found.
 */
function _know4pol_core_get_accessible_vocabs($bundle, array $gids) {
  $vids = array();
  if ($gids) {
    $query = db_select('og_vocab', 'ogv');
    $query->join('og_vocab_relation', 'ovr', 'ogv.vid = ovr.vid');
    $query->fields('ogv', array('vid'))
      ->condition('gid', $gids, 'IN')
      ->condition('bundle', $bundle);
    $vids = $query->execute()->fetchAllAssoc('vid');
  }
  return $vids;
}

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function know4pol_core_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  $targets['field_related_organisations:acronym']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:label']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:etid']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary:label']['callback'] = '_know4pol_core_post_process_callback';
  if ($entity_type == 'node') {
    $content_type_og_vocabularies = _know4pol_core_get_og_vocabularies_by_content_type($bundle_name);
    foreach ($content_type_og_vocabularies as $vocab) {
      $targets['og_vocabulary:' . $vocab->machine_name]['name'] = 'og_vocabulary:' . $vocab->name;
      $targets['og_vocabulary:' . $vocab->machine_name]['callback'] = '_know4pol_core_post_process_callback';
      $targets['og_vocabulary:' . $vocab->machine_name]['summary_callbacks'] = array('taxonomy_feeds_summary_callback');
      $targets['og_vocabulary:' . $vocab->machine_name]['form_callbacks'] = array('taxonomy_feeds_form_callback');
    }
  }
}

/**
 * Get all Vocabularies related to a group.
 */
function _know4pol_core_get_og_vocabularies_by_content_type($bundle_name) {
  $query = db_select('og_vocab', 'ov');
  $query->join('taxonomy_vocabulary', 'tv', 'tv.vid = ov.vid');
  $query->fields('ov', array('vid'))
    ->fields('tv', array('name', 'machine_name'))
    ->condition('bundle', $bundle_name);
  $result = $query->execute()->fetchAll();
  return $result;
}

/**
 * Custom Entity reference callback for "og_group_ref"/"og_vocab" field mapping.
 *
 * When the callback is invoked, $target contains the name of the field the
 * user has decided to map to and $value contains the value of the feed item
 * element the user has picked as a source.
 *
 * @param FeedsSource $source
 *   A FeedsSource object.
 * @param object $entity
 *   The entity to map to.
 * @param string $target
 *   The target key on $entity to map to.
 * @param array $value
 *   The value to map. MUST be an array.
 */
function _know4pol_core_post_process_callback(FeedsSource $source, $entity, $target, array $value, array $mapping) {
  // Add in default values.
  $mapping += array(
    'term_search' => FEEDS_TAXONOMY_SEARCH_TERM_NAME,
    'autocreate' => FALSE,
  );
  // First we define if the entity to change is a term or a node.
  if ($entity->feeds_item->entity_type == 'taxonomy_term') {
    $entity_id_key = 'tid';
  }
  else {
    $entity_id_key = 'nid';
  }
  // Then we get the status before processing the import.
  $entity_unchanged = entity_load_unchanged($entity->feeds_item->entity_type, $entity->$entity_id_key);
  // The customisation of the callback is only for the field "og_group_ref".
  $existing_og_group_ref = $entity_unchanged->og_group_ref;
  // Don't do anything if we weren't given any data.
  if (empty($value)) {
    return;
  }
  // Assume that the passed in value could really be any number of values.
  if (is_array($value)) {
    $values = $value;
  }
  else {
    $values = array($value);
  }
  // Determine the field we are matching against.
  if (strpos($target, ':') === FALSE) {
    $match_key = 'guid';
  }
  else {
    list($target, $match_key) = explode(':', $target, 2);
  }
  // Get some useful field information.
  $info = field_info_field($target);
  if ($match_key == 'label') {
    $handler = entityreference_get_selection_handler($info);
  }
  // Iterate over all values.
  $field = isset($entity->$target) ? $entity->$target : array();
  foreach ($values as $value) {
    // Only process if this value was set for this instance.
    if ($value) {
      switch ($match_key) {
        case 'guid':
        case 'url':
          // Fetch the entity ID resulting from the mapping table look-up.
          $entity_id = db_select('feeds_item', 'fi')
            ->fields('fi', array('entity_id'))
            ->condition($match_key, $value, '=')
            ->execute()
            ->fetchField();
          break;

        case 'etid':
          $entity_id = $value;
          break;

        case 'label':
          $options = $handler->getReferencableEntities($value, '=');
          if ($options) {
            // Change the logic for "og_vocabulary:label".
            if ($target == 'og_vocabulary') {
              foreach ($options as $key => $value) {
                $vocab = taxonomy_vocabulary_machine_name_load($key);
                $vocab_relation = og_vocab_relation_get($vocab->vid);
                if (!empty($vocab_relation)) {
                  $etids[] = array_keys($options[$key]);
                }
              }
              $og_vocabulary_term_ids = array_values($etids);
            }
            else {
              $options = reset($options);
              $etids = array_keys($options);
            }
          }
          // Use the first matching entity.
          $entity_id = reset($etids);
          break;

        default:
          // This is to assign items to a specific og vocabulary.
          if ($target == 'og_vocabulary') {
            // Get some useful field information.
            $info = field_info_field($target);
            $handler = entityreference_get_selection_handler($info);
            $options = $handler->getReferencableEntities($value, '=');
            if (!empty($options[$match_key])) {
              $etid = array_keys($options[$match_key]);
            }
            $entity_id = "";
            if (!empty($etid)) {
              $entity_id = reset($etid);
            }
            if ($mapping['autocreate']) {
              $mapping_target = drupal_substr($mapping['target'], drupal_strlen('og_vocabulary:'));
              $terms = taxonomy_get_term_by_name($value, $mapping_target);
              $term = reset($terms);
              if (empty($term)) {
                $vocab = taxonomy_vocabulary_machine_name_load($mapping_target);
                $vocab_id = $vocab->vid;
                $term = (object) array(
                  'name' => drupal_substr($value, 0, 255),
                  'vid' => $vocab_id,
                  'vocabulary_machine_name' => $mapping_target,
                );
                taxonomy_term_save($term);
              }
            }
          }
          if ($target == 'field_related_organisations') {
            // Get the related organisation nid.
            $query = db_select('node', 'n')
              ->fields('n', array('nid'));
            $query->join('field_data_field_org_acronym', 'oc', 'oc.entity_id = n.nid');
            $query->condition('n.type', 'organisation')
              ->condition('field_org_acronym_value', $value);

            $etid = $query->execute()->fetch();
            $entity_id = "";
            if (!empty($etid)) {
              $entity_id = $etid->nid;
            }
          }
          break;
      }
      /*
       * Only add a reference to an existing entity ID if there exists a
       * mapping between it and the provided GUID.  In cases where no such
       * mapping exists (yet), don't do anything here.  There may be a mapping
       * defined later in the CSV file.  If so, and the user re-runs the import
       * (as a second pass), we can add this reference then.  (The "Update
       * existing nodes" option must be selected during the second pass.)
       */
      if (isset($og_vocabulary_term_ids)) {
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        foreach ($og_vocabulary_term_ids as $key => $value) {
          // Assign the target ID.
          if (!in_array($value[0], $existing_target_ids)) {
            $field[LANGUAGE_NONE][]['target_id'] = (string) $value[0];
          }
        }
      }
      elseif ($entity_id) {
        // Assign the target ID.
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        if (!in_array($entity_id, $existing_target_ids)) {
          $field[LANGUAGE_NONE][]['target_id'] = (string) $entity_id;
        }
      }
      else /* there is no $entity_id, no mapping */ {
        /*
         * Feeds stores a hash of every line imported from CSVs in order to
         * make the import process more efficient by ignoring lines it's
         * already seen.  We need to short-circuit this process in this case
         * because users may want to re-import the same line as an update later
         * when (and if) a map to a reference exists.  So in order to provide
         * this opportunity later, we need to destroy the hash.
         */
        unset($entity->feeds_item->hash);
        $source->log('entityreference', t('No existing entity found for entity @source_id entityreference to source entity @value', array('@source_id' => $entity->feeds_item->entity_id, '@value' => $value)));
      }
    }
    // Break out of the loop if this field is single-valued.
    if ($info['cardinality'] == 1) {
      break;
    }
  }

  // If the "og_group_ref" field has an old value,
  // then add the old and the new value.
  // Otherwise just add the field to the entity definition.
  if (!empty($existing_og_group_ref) && $target == 'og_group_ref') {
    $entity->og_group_ref = drupal_array_merge_deep($existing_og_group_ref, $field);
  }
  else {
    $entity->{$target} = $field;
  }
}

/**
 * Implements hook_feeds_presave().
 */
function know4pol_core_feeds_presave(FeedsSource $source, $entity, $item, $entity_id) {
  // For all imports, if the content is imported as published,
  // then we set the moderation to published as well.
  // This is not handled by Workbench_moderation module.
  if ($entity->status == "1") {
    $entity->workbench_moderation_state_new = workbench_moderation_state_published();
  }
  // Check first if we have any topics from Newsroom.
  if (!empty($entity->field_newsroom_topics[LANGUAGE_NONE])) {
    foreach ($entity->field_newsroom_topics[LANGUAGE_NONE] as $value) {
      $matched_term_in_tags = "";
      $matched_term_in_knowledge_service_og = "";
      // For each topic, first we load it,
      // in order to get its category and name.
      $entity_term = taxonomy_term_load($value['tid']);
      // If the category is "Knowledge4Policy Keywords".
      if ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge4Policy Keywords") {
        // Then we search its equivalent in "tags" vocabulary.
        $matched_term_in_tags = taxonomy_get_term_by_name($entity_term->name, 'tags');
        if (!empty($matched_term_in_tags)) {
          $matched_term_in_tags = array_shift($matched_term_in_tags);
          // Add the tag to the imported entity.
          $poparray = function ($value) {
            return $value['tid'];
          };
          if (!empty($entity->field_tags[LANGUAGE_NONE])) {
            $entity_tags[] = array_map($poparray, $entity->field_tags[LANGUAGE_NONE]);
            if (!in_array($matched_term_in_tags->tid, $entity_tags)) {
              $entity->field_tags[LANGUAGE_NONE][]['tid'] = $matched_term_in_tags->tid;
            }
          }
        }
      }
      // Else if the category is "Knowledge Service".
      elseif ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge Service") {
        // Then we search in "knowledge_centre" content type.
        // because it's a node reference.
        $query = new EntityFieldQuery();
        $matched_term_in_knowledge_service_og = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('type', 'knowledge_centre')
          ->propertyCondition('title', $entity_term->name)
          ->propertyCondition('status', 1)
          ->range(0, 1)
          ->execute();
        if (!empty($matched_term_in_knowledge_service_og)) {
          $matched_term_in_knowledge_service_og = array_shift($matched_term_in_knowledge_service_og['node']);
          // Add the related OG group to the imported entity.
          $entity->og_group_ref[LANGUAGE_NONE][]['target_id'] = $matched_term_in_knowledge_service_og->nid;
        }
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function know4pol_core_block_info() {
  $blocks = array();
  $blocks['know4pol_ks_latest_content'] = array(
    'info' => t('Know4pol KS latest content block'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['know4pol_ks_admin_menu'] = array(
    'info' => t('Know4pol KS admin block'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function know4pol_core_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'know4pol_ks_latest_content':
      $block['content'] = '<ul class="ecl-listing ecl-listing--three-columns">';
      $item = menu_get_item();
      if (!empty($item['page_arguments'][0]->nid)) {
        // Block 1 : latest news.
        $view1 = views_get_view_result('ks_latest_content', 'latest_news', $item['page_arguments'][0]->nid);
        if (count($view1)) {
          $block_latest_news = views_embed_view('ks_latest_content', 'latest_news', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Latest News</h3>' . $block_latest_news . '</div></li>';
        }
        // Block 2 : next events.
        $view2 = views_get_view_result('ks_latest_content', 'next_events', $item['page_arguments'][0]->nid);
        if (count($view2)) {
          $block_next_events = views_embed_view('ks_latest_content', 'next_events', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Next Events</h3>' . $block_next_events . '</div></li>';
        }
        // Block 3 : latest resources.
        $view3 = views_get_view_result('ks_latest_content', 'latest_resources', $item['page_arguments'][0]->nid);
        if (count($view3)) {
          $block_latest_resources = views_embed_view('ks_latest_content', 'latest_resources', $item['page_arguments'][0]->nid);
          $block['content'] .= '<li class="ecl-list-item ecl-list-item--three-columns"><div class="ecl-list-item__body"><h3 class="ecl-list-item__title ecl-heading ecl-heading--h3">Latest Resources</h3>' . $block_latest_resources . '</div></li>';
        }
        $block['content'] .= '</ul>';
      }
      break;

    case 'know4pol_ks_admin_menu':
      $block['content'] = _know4pol_core_theme_ks_admin_menu(_know4pol_core_get_ks_admin_menu('menu-ks-admin-menu'));
      break;
  }
  return $block;
}

/**
 * Prepares menu array for theming.
 *
 * @param string $menu_name
 *   Machine name of KS admin menu.
 *
 * @return array
 *   Generated menu array.
 */
function _know4pol_core_get_ks_admin_menu($menu_name) {
  $loaded_menu = menu_tree_page_data($menu_name);
  $output = array();
  if (!empty($loaded_menu)) {
    foreach ($loaded_menu as $loaded_menu_parent_item) {
      $child_items = $loaded_menu_parent_item['below'];
      if (!empty($child_items)) {
        foreach ($child_items as $child_item) {
          $attributes = array(
            'attributes' =>
              array(
                'class' =>
                  array(
                    'ecl-link',
                    'ecl-link--standalone',
                    'ecl-link-block__link',
                  ),
              ),
          );
          $links[] = l($child_item['link']['link_title'], $child_item['link']['href'], $attributes);
        }
      }
      else {
        $links = '';
      }
      $output[$loaded_menu_parent_item['link']['link_title']]['title'] = $loaded_menu_parent_item['link']['link_title'];
      $output[$loaded_menu_parent_item['link']['link_title']]['link'] = '<a class="ecl-button ecl-button--primary" href="' . url($loaded_menu_parent_item['link']['href']) . '">' . $loaded_menu_parent_item['link']['link_title'] . '</a>';
      $output[$loaded_menu_parent_item['link']['link_title']]['links'] = $links;
      unset($links);
    }
  }
  return $output;
}

/**
 * Wraps links into set of buttons and dropdowns.
 *
 * @param array $menuarray
 *   Generated menu array.
 *
 * @return string
 *   Generated menu.
 */
function _know4pol_core_theme_ks_admin_menu(array $menuarray) {
  $output = "";
  foreach ($menuarray as $parent) {
    if ($parent['links']) {
      $output .= '<div class="element">
                  <div class="ecl-dropdown">
                    <button class="ecl-button ecl-button--default ecl-expandable__button"
                            aria-controls="' . $parent['title'] . '-button-dropdown" aria-expanded="false"
                            id="' . $parent['title'] . '-expandable-button"
                            type="button">' . $parent['title'] . '
                    </button>
                  <div class="ecl-link-block ecl-dropdown__body" id="' . $parent['title'] . '-button-dropdown" aria-labelledby="' . $parent['title'] . '-expandable-button" aria-hidden="true">
                  <ul class="ecl-link-block__list">';
      foreach ($parent['links'] as $link) {
        $output .= '<li class="ecl-link-block__item">' . $link . '</li>';
      }
      $output .= '</ul></div></div></div>';
    }
    else {
      $output .= '<p class="element">' . $parent['link'] . '</p>';
    }
  }
  return $output;
}

/**
 * Implements hook_og_ui_get_group_admin().
 */
function know4pol_core_og_ui_get_group_admin($group_type, $gid) {
  $items = array();
  if (og_user_access($group_type, $gid, 'add user')) {
    $items['know4pol_content'] = array(
      'title' => t('View all KS content'),
      'description' => t('Manage all KS content'),
      'href' => 'admin/content',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_files'] = array(
      'title' => t('View all KS files'),
      'description' => t('Manage all KS files'),
      'href' => 'admin/files',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_sharing_content'] = array(
      'title' => t('Assign/Unassign content to KS'),
      'description' => t('Assign/Unassign content to KS'),
      'href' => 'admin/sharing-content',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
  }
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function know4pol_core_menu_alter(&$items) {
  $items['node/add']['access callback'] = '_know4pol_core_node_add_access';
  $items['admin/index']['access callback'] = '_know4pol_core_node_add_access';
  $items['admin/workbench/create']['access callback'] = '_know4pol_core_node_add_access';
  $items['group/node/%/admin/content']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/content']['access arguments'] = array('view manage KS content section',
    'node',
    2,
  );
  $items['group/node/%/admin/files']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/files']['access arguments'] = array('view manage KS content section',
    'node',
    2,
  );
  $items['group/node/%/admin/sharing-content']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/sharing-content']['access arguments'] = array('view manage KS content section',
    'node',
    2,
  );
  $items['node/%node/moderation/%/unpublish']['access callback'] = '_know4pol_core_unpublish_access';
  $items['node/%node/moderation/%/unpublish']['access arguments'] = array(1);
}

/**
 * Access callback: check if the user has the given OG permission.
 *
 * @param string $perm
 *   The permission to check.
 * @param string $group_type
 *   The group type.
 * @param string $gid
 *   The group id.
 */
function _know4pol_core_get_og_access($perm, $group_type, $gid) {
  $gid = (int) $gid;
  return ($gid > 0 && og_user_access($group_type, $gid, $perm));
}

/**
 * Access callback: function for add content menu item.
 *
 * @return bool
 *   TRUE if the user has add permission, otherwise FALSE.
 *
 * @see _node_add_access()
 */
function _know4pol_core_node_add_access() {
  if (user_access('administer nodes')) {
    return _node_add_access();
  }
  return FALSE;
}

/**
 * Implements hook_action_info().
 */
function know4pol_core_action_info() {
  return array(
    '_know4pol_core_assign_ks_action' => array(
      'type' => 'entity',
      'label' => t('Assign content to the current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    '_know4pol_core_unassign_ks_action' => array(
      'type' => 'entity',
      'label' => t('Remove content from the current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_assign_ks_action($entity, array $context) {
  $target_group_id = $context['view_info']['arguments'][0];
  $next = count($entity->og_group_ref[LANGUAGE_NONE]);
  $entity->og_group_ref[LANGUAGE_NONE][$next]['target_id'] = $target_group_id;
  node_save($entity);
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_unassign_ks_action($entity, array $context) {
  $target_group_id = $context['view_info']['arguments'][0];
  $og_array = $entity->og_group_ref[LANGUAGE_NONE];
  foreach ($og_array as $key => $value) {
    if ($value['target_id'] == $target_group_id) {
      unset($og_array[$key]);
    }
  }
  $entity->og_group_ref[LANGUAGE_NONE] = array_values($og_array);
  node_save($entity);
}

/**
 * Implements hook_field_display_alter().
 */
function know4pol_core_field_display_alter(&$display, $context) {
  // Add the <p> tag to the field_ne_body summary, if not available.
  if (isset($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
  // Add the <p> tag to the body summary, if not available.
  if (isset($context['entity']->body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
}

/**
 * Implements hook_preprocess_html().
 */
function know4pol_core_preprocess_html(&$variables) {
  global $theme;
  if ($theme == 'seven') {
    drupal_add_css(drupal_get_path('module', 'know4pol_core') . '/css/know4pol_core_admin.css');
  }
}

/**
 * Implements hook_views_query_alter().
 */
function know4pol_core_views_query_alter(&$view, &$query) {
  if ($view->name == 'organisation_related_knowledge_services') {
    // Get the nid.
    if ($node = menu_get_object()) {
      $nid = $node->nid;
    }
    $dbquery = db_select('og_membership', 'om');
    $dbquery->distinct();
    $dbquery->fields('om', array('gid'));
    $dbquery->condition('etid', $nid);
    $result = $dbquery->execute()->fetchAll();
    foreach ($result as $row) {
      $tids[] = $row->gid;
    }
    $query->add_where(1, 'node.nid', $tids, 'IN');
  }
}

/**
 * Implements hook_webform_select_options_info().
 */
function know4pol_core_webform_select_options_info() {
  $items = array();
  $items['states'] = array(
    'title' => t('Knowledge services'),
    'options callback' => '_know4pol_core_webform_options_knowledge_services',
  );
  return $items;
}

/**
 * Get the list of all published KS names.
 *
 * @return array
 *   List of all published Knowledge services.
 */
function _know4pol_core_webform_options_knowledge_services() {
  $query = db_select('node', 'n')
    ->fields('n', array('nid', 'title'))
    ->condition('type', 'knowledge_centre')
    ->condition('status', 1);
  $knowledge_services = $query->execute()->fetchAllAssoc('nid');
  $ks_list = array();
  foreach ($knowledge_services as $nid => $knowledge_service) {
    $ks_list[$nid] = $knowledge_service->title;
  }
  return $ks_list;
}

/**
 * Implements hook_ds_fields_info().
 */
function know4pol_core_ds_fields_info($entity_type) {
  $fields = array();

  $fields['node']['ks_name_topic_specific_taxonomies'] = array(
    'title' => t('Knowledge service | Topics | Specific keywords'),
    'field_type' => DS_FIELD_TYPE_FUNCTION,
    'function' => '_know4pol_core_render_ks_name_topic_specific_taxonomies',
  );

  return $fields;
}

/**
 * Helper function that creates a custom ds field.
 *
 * @param array $field
 *   All information on the field and its parent entity.
 *
 * @return string
 *   Space, to have it render.
 */
function _know4pol_core_render_ks_name_topic_specific_taxonomies(array $field) {
  $content = "";
  $menu = menu_get_item();

  // Let's define the three fields to be shown.
  $knowledge_services_topics = isset($menu['page_arguments'][0]->field_ks_related_topics[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->field_ks_related_topics[LANGUAGE_NONE] : array();
  $knowledge_services_specific_keywords = isset($menu['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE] : array();
  $knowledge_services = isset($menu['page_arguments'][0]->og_group_ref[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->og_group_ref[LANGUAGE_NONE] : array();

  // Let's filter topics/specific keywords by knowledge service.
  foreach ($knowledge_services as $knowledge_service) {
    // Go to line for the new knowledege services.
    if ($content != "") {
      $content .= '<br>';
    }
    $content .= _know4pol_core_get_topic_keywords_fields_by_ks($knowledge_services_topics, $knowledge_services_specific_keywords, $knowledge_service);
  }
  return $content;
}

/**
 * Filter topics/specific keywords by knowledge service.
 *
 * @param array $knowledge_services_topics
 *   A list of topics.
 * @param array $knowledge_services_specific_keywords
 *   A list of specific keywords.
 * @param array $knowledge_service
 *   A knowledge service.
 *
 * @return string
 *   The rendered content.
 */
function _know4pol_core_get_topic_keywords_fields_by_ks(array $knowledge_services_topics, array $knowledge_services_specific_keywords, array $knowledge_service) {
  $content = "";
  // First add the name of the knowledge service.
  $knowledge_service_node = node_load($knowledge_service['target_id']);
  $ks_name = $knowledge_service_node->title;
  $ks_url_alias = $knowledge_service_node->path['alias'];
  $content .= l($ks_name, $ks_url_alias, array('attributes' => array('class' => array('ecl-tag__item', 'know4pol-main-resource-meta-link'))));

  // Second create the list of topics per knowledge service.
  $ks_topics_content = "";
  foreach ($knowledge_services_topics as $knowledge_services_topic) {
    $knowledge_services_topic_term = node_load($knowledge_services_topic['target_id']);
    if ($knowledge_services_topic_term->og_group_ref[LANGUAGE_NONE][0]['target_id'] == $knowledge_service['target_id']) {
      $ks_topics_content .= _know4pol_core_create_topic_link($knowledge_services_topic_term->title, $knowledge_services_topic_term->path['alias']);
    }
  }
  if ($ks_topics_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_topics_content);
  }

  // Third add the list of specific keywords per KS.
  // First get the default vocabulary from the knowledge service content type.
  $ks_keyword_content = "";
  if (isset($knowledge_service_node->field_the_main_ks_keywords_vocab[LANGUAGE_NONE][0]['target_id'])) {
    $main_ks_keywords_vocab_id = $knowledge_service_node->field_the_main_ks_keywords_vocab[LANGUAGE_NONE][0]['target_id'];
    $ks_terms = array_keys(entity_load('taxonomy_term', FALSE, array('vid' => $main_ks_keywords_vocab_id)));
    foreach ($knowledge_services_specific_keywords as $ks_keyword) {
      if (in_array($ks_keyword['target_id'], $ks_terms)) {
        $ks_keyword_content .= _know4pol_core_create_keyword_content_link($ks_keyword, $knowledge_service);
      }
    }
  }
  if ($ks_keyword_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_keyword_content);
  }

  return $content;
}

/**
 * Create the topic link.
 *
 * @param string $ks_topics_content_title
 *   A knowledge service topic.
 * @param string $ks_topics_content_path
 *   A knowledge service topic.
 */
function _know4pol_core_create_topic_link($ks_topics_content_title, $ks_topics_content_path) {
  return l($ks_topics_content_title, $ks_topics_content_path, array('attributes' => array('class' => array('ecl-tag__item'))));
}

/**
 * Create the keyword link.
 *
 * @param array $ks_keyword
 *   A Knowledge service keyword.
 * @param array $knowledge_service
 *   The related knowledge service.
 */
function _know4pol_core_create_keyword_content_link(array $ks_keyword, array $knowledge_service) {
  global $base_url;
  $ks_keyword_term = taxonomy_term_load($ks_keyword['target_id']);
  $ks_keyword_content_title = $ks_keyword_term->name;
  $ks_keyword_content_path = $base_url . '/search/site';
  return l($ks_keyword_content_title, $ks_keyword_content_path,
                                array(
                                  'attributes' => array('class' => array('ecl-tag__item')),
                                  'query' => array('f[0]' => 'sm_og_vocabulary:taxonomy_term:' . $ks_keyword_term->tid, 'f[1]' => 'sm_og_group_ref:node:' . $knowledge_service['target_id']),
                                ));
}

/**
 * Add "|" sign before the given text.
 *
 * @param string $content
 *   The content to be changed.
 */
function _know4pol_core_add_seperation_bar($content) {
  return '|' . $content;
}

/**
 * Implements hook_webform_submission_presave().
 */
function know4pol_core_webform_submission_presave(&$node, &$submission) {
  // Feedback form.
  if ($submission->nid == 31016) {
    // KS field filled && OG module enabled.
    if (module_exists('og') && drupal_strlen($submission->data[1][0])) {
      // Get OG group editors and append mails.
      foreach (_know4pol_core_get_og_group_members_mails($submission->data[1][0], array('editor member')) as $user_mail) {
        $node->webform['emails'][1]['email'] .= ',' . $user_mail;
      }
    }
  }
}

/**
 * Get users from an og group, with a given role .
 *
 * @param int $gid
 *   The group id.
 * @param array $roles
 *   The role(s) the users must have in the group.
 *
 * @return array
 *   An array of users
 */
function _know4pol_core_get_og_group_members_mails($gid, array $roles = array()) {
  // Check it's a group and load it.
  if (og_is_group('node', $gid)) {
    // Check if the $roles list is an array.
    if (!is_array($roles)) {
      $roles = array($roles);
    }
    // Get the group node information.
    $group = node_load($gid);

    // Get the mail list of the members.
    $mail_list = "";
    $members = og_get_group_members_properties($group, array(), 'members__' . OG_STATE_ACTIVE, 'node');
    foreach ($members as $uid) {
      if (count(array_intersect(og_get_user_roles($group->entity_type, $gid, $uid), $roles)) > 0) {
        $user = user_load($uid);
        $mail_list[$user->mail] = $user->mail;
      }
    }

    // Add the Official KS mails, if exist.
    if (!empty($group->field_official_ks_notif_mails[LANGUAGE_NONE])) {
      foreach ($group->field_official_ks_notif_mails[LANGUAGE_NONE] as $ks_mail) {
        $mail_list[$ks_mail['email']] = $ks_mail['email'];
      }
    }
    return count($mail_list) ? $mail_list : NULL;
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function know4pol_core_entity_property_info_alter(&$info) {
  $info['node']['properties']['current-revision-author-username'] = array(
    'label' => t('Current revision author username'),
    'type' => 'text',
    'description' => t('The username of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-realname'] = array(
    'label' => t('Current revision author realname'),
    'type' => 'text',
    'description' => t('The realname of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-mail'] = array(
    'label' => t('Current revision author email'),
    'type' => 'text',
    'description' => t('The email of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
}

/**
 * Implements hook_multisite_drupal_toolbox_filter_options_alter().
 */
function know4pol_core_multisite_drupal_toolbox_filter_options_alter(&$filter_options) {
  // Enable the <iframe> tag, strongly not advised of course.
  $filter_options['valid_elements']['iframe'] = array('*' => TRUE);
}

<?php

/**
 * @file
 * Code for the know4pol-core feature.
 */

module_load_include('inc', 'know4pol_core', 'includes/know4pol_core_views');
module_load_include('inc', 'know4pol_core', 'includes/know4pol_core_settings');

/**
 * Implements hook_field_default_field_instances_alter().
 */
function know4pol_core_field_default_field_instances_alter(&$fields) {
  // Event content type.
  if (!empty($fields['node-page-field_ne_body'])) {
    $fields['node-page-field_ne_body']['settings']['entity_translation_sync'] = FALSE;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_user_admin_permissions_alter(&$form, &$form_state, $form_id) {
  $form['role_permissions'] = array(
    '#type' => 'value',
    '#value' => array(),
  );
  foreach ($form['role_names'] as $rid => $role) {
    if (strpos($rid, '#') !== FALSE) {
      continue;
    }
    $role_permissions = user_role_permissions(array($rid => $rid));
    $form['role_permissions']['#value'][$rid] = $role_permissions[$rid];
  }
  $form['#submit'][] = '_know4pol_core_form_user_admin_permissions_alter_submit';
}

/**
 * Log the changed user permissions.
 *
 * @param string $form
 *   The submitted form.
 * @param string $form_state
 *   The submitted form states.
 */
function _know4pol_core_form_user_admin_permissions_alter_submit(&$form, &$form_state) {
  global $user;
  foreach ($form['role_permissions']['#value'] as $rid => $role_permissions) {
    $data = array();
    foreach ($form_state['values'][$rid] as $permission => $value) {
      if (!isset($role_permissions[$permission])) {
        if ($value) {
          $data[$permission] = 1;
        }
      }
      elseif (!$role_permissions[$permission] && $value) {
        $data[$permission] = 1;
      }
      elseif ($role_permissions[$permission] && !$value) {
        $data[$permission] = 0;
      }
    }
    if (count($data)) {
      watchdog('permissions_changes',
        'The user "%user" changed the following permission(s) for the role "%role" to : %permissions',
        array(
          '%user' => $user->name,
          '%permissions' => print_r($data, TRUE),
          '%role' => $form['role_names'][$rid]['#markup'],
        ),
        WATCHDOG_NOTICE,
        NULL);
    }
  }
}

/**
 * Implements hook_og_permission().
 */
function know4pol_core_og_permission() {
  return array(
    'view manage KS content section' => array(
      'title' => t('View "manage KS content" in admin toolbar'),
    ),
    'unpublish ks content' => array(
      'title' => t('Unpublish KS content'),
      'description' => t('Unpublish KS content'),
    ),
    /* Define a permission to view moderation history to allow users to see content they can moderate */
    'view moderation history' => array(
      'title' => t('View moderation history'),
    ),
    'administer ks settings' => array(
      'title' => t('Administer KS settings'),
    ),
    'assign and unassign ks content' => array(
      'title' => t('Assign/Unassign KS content'),
    ),
    'suggest ks content' => array(
      'title' => t('Suggest KS content'),
    ),
  );
}

/**
 * Implements hook_workbench_moderation_access_alter().
 *
 * Grants access to drafts and revisions to users with the 'view moderation
 * history' group permission.
 *
 * Note that the current user only needs the permission in one of the groups
 * this node belongs to in order to see drafts and moderation history.
 *
 * @see _workbench_moderation_access_current_draft()
 */
function know4pol_core_workbench_moderation_access_alter(&$access, $op, $node) {
  if ($access || !($op == 'view history' || $op == 'view revisions')) {
    return;
  }

  // Get groups for this node.
  $og_groups = og_get_entity_groups('node', $node, array(OG_STATE_ACTIVE));

  // Bail if this node isn't in a group.
  if (!isset($og_groups['node'])) {
    return;
  }

  foreach ($og_groups['node'] as $group_id) {
    // Check if the user can view moderation history in this group. If that is
    // correct, access is granted.
    if ($access = og_user_access_entity('view moderation history', 'node', $group_id)) {
      // When access has been granted, no need to check further.
      return;
    }
  }
}

/**
 * Implements Implements hook_token_info().
 */
function know4pol_core_token_info() {
  $site['know4pol_og_group_ref'] = array(
    'name' => t('List of knowledge services'),
    'description' => t('List of knowledge services seperated by plus sign)'),
  );

  return array(
    'tokens' => array(
      'site' => $site,
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function know4pol_core_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  if ($type == 'site') {
    foreach ($tokens as $name => $original) {

      if ($name == 'know4pol_og_group_ref') {
        $gids = array();

        // Try to locate node data.
        if (isset($data['node'])) {
          $node = $data['node'];
        }
        // Using Field collection ? See KNOW4POL-455.
        elseif (isset($data['field_collection_item'])) {
          $node = $data['field_collection_item']->hostEntity();
        }
        else {
          $mgi = menu_get_item();
          if (isset($mgi['page_arguments']) && $mgi['page_arguments'][0] == 'node') {
            $node = $mgi['page_arguments'][1];
          }
        }

        // We get a node, and has the field we need.
        if (isset($node->og_group_ref) && !empty($node->og_group_ref)) {
          foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
            $gids[] = $gid['target_id'];
          }
        }
        // Maybe specified in static variable for specific case.
        elseif (!empty($static_gids = drupal_static('know4pol_core_og_group_ref'))) {
          $gids = $static_gids;
        }
        // New content, try to find gid in query parameters.
        else {
          // For ajax calls and new content.
          if (strpos(current_path(), '/ajax') !== FALSE) {
            // We need to find this in refferer.
            parse_str(drupal_parse_url($_SERVER['HTTP_REFERER'], PHP_URL_QUERY), $url_parameters);
          }
          else {
            $url_parameters = drupal_get_query_parameters();
          }

          if (isset($url_parameters['og_group_ref']) && !empty($url_parameters['og_group_ref'])) {
            $gids[] = $url_parameters['og_group_ref'];
          }

        }
        $replacements[$original] = implode('+', $gids);
        break;
      }
    }
  }

  if ($type == 'entity' && $data['entity_type'] == 'node') {
    $node = $data['entity'];
    if (isset($node->revision_uid)) {
      $revision_author = user_load($node->revision_uid);
      $sanitize = !empty($options['sanitize']);
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'current-revision-author-username':
            $replacements[$original] = $sanitize ? check_plain($revision_author->name) : $revision_author->name;
            break;

          case 'current-revision-author-realname':
            $replacements[$original] = $sanitize ? check_plain($revision_author->realname) : $revision_author->realname;
            break;

          case 'current-revision-author-mail':
            $replacements[$original] = $sanitize ? check_plain($revision_author->mail) : $revision_author->mail;
            break;
        }
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function know4pol_core_form_node_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['#node'])) {
    switch ($form['#node']->type) {
      case  'publication':
        // Disable all fields if it's coming from Pubsy.
        if ($form['#node']->uid == '1') {
          $form['title']['#disabled'] = TRUE;
          $form['field_pub_image']['#disabled'] = TRUE;
          $form['body']['#disabled'] = TRUE;
          $form['field_pub_links']['#disabled'] = TRUE;
          $form['field_pub_files_ref']['#disabled'] = TRUE;
          $form['field_last_update']['#disabled'] = TRUE;
          $form['field_pub_type']['#disabled'] = TRUE;
          $form['field_related_organisations']['#disabled'] = TRUE;
          $form['field_project_activity']['#disabled'] = TRUE;
          $form['field_pub_dc_date_accessioned']['#disabled'] = TRUE;
          $form['field_pub_dc_date_available']['#disabled'] = TRUE;
          $form['field_pub_dc_date_created']['#disabled'] = TRUE;
          $form['field_pub_dc_date_submitted']['#disabled'] = TRUE;
          $form['field_pub_dc_date_issued']['#disabled'] = TRUE;
          $form['field_pub_dc_rel_ispartofseries']['#disabled'] = TRUE;
          $form['field_pub_pubsy_identities']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_doi']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_isbn']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_issn']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_eur']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_opoce']['#disabled'] = TRUE;
          $form['field_pub_dc_identifier_uri']['#disabled'] = TRUE;
          $form['field_pub_dc_publisher']['#disabled'] = TRUE;
          $form['field_pub_dc_contributor_authors']['#disabled'] = TRUE;
          $form['field_pub_dc_descrip_abstract']['#disabled'] = TRUE;
          $form['field_pub_dc_descrip_sponsorship']['#disabled'] = TRUE;
          $form['field_pub_dc_format_medium']['#disabled'] = TRUE;
          $form['field_pub_dc_language']['#disabled'] = TRUE;
          $form['field_pub_dc_type']['#disabled'] = TRUE;
        }
        break;
    }

    // Specific field in all content types.
    if (isset($form['field_banner_image'])) {
      if (!user_has_role(7)) {
        // KNOW4POL-397, banner image: only admin can setup this field.
        $form['field_banner_image']['#disabled'] = TRUE;
      }
    }

    // KNOW4POL-504 - Group topics by KS for field-ks-related-topics.
    if (isset($form['field_ks_related_topics'])) {
      $options = array();
      // Go through all current options;.
      foreach ($form['field_ks_related_topics'][LANGUAGE_NONE]['#options'] as $k => $v) {
        if ($k == '_none') {
          // None value, copy for later and skip.
          $none = $v;
          continue;
        }
        // Get topic and KS name from option name.
        if (preg_match('/^(.*) \- (.*)$/i', $v, $match)) {
          $ks = $match[2];
          $topic = $match[1];
        }
        // If not split, use default parent.
        else {
          $ks = '$default';
          $topic = $v;
        }
        // Create category if not in the list.
        if (!isset($options[$ks])) {
          $options[$ks] = array();
        }
        $options[$ks][$k] = $match[1];
      }

      // If not more than 2 categories, get a flat list.
      if (count($options) < 2) {
        $options = array_pop($options);
      }

      // Set back _none option.
      if (isset($none)) {
        $options['_none'] = $none;
      }

      // Update values.
      $form['field_ks_related_topics'][LANGUAGE_NONE]['#options'] = $options;
    }

  }

  $form['actions']['unpublish'] = array(
    '#type' => 'submit',
    '#value' => 'Unpublish',
    '#submit' => array('_know4pol_core_unpublish_submit'),
    '#access' => _know4pol_core_unpublish_access(),
    '#weight' => 100,
  );
  $form['#attributes']['class'][] = 'js-confirm-pop-up';
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'know4pol_core') . '/js/js_confirm_pop_up.js',
  );
}

/**
 * The callback function for the unpublish button.
 */
function _know4pol_core_unpublish_submit($form, &$form_state) {
  if ($form_state['values']['unpublish'] == 'Unpublish') {
    drupal_goto('node/' . $form['nid']['#value'] . '/moderation/' . $form['vid']['#value'] . '/unpublish');
  }
}

/**
 * The access function for the unpublish button.
 */
function _know4pol_core_unpublish_access($node = array()) {
  global $user;
  if (empty($node)) {
    $node = menu_get_object();
  }
  // We should fisr make sure that we're editing
  // and not creating a new content.
  if (!empty($node->og_group_ref[LANGUAGE_NONE])) {
    // If admin/webmaster, we bypass the right.
    if (in_array('administrator', array_values($user->roles)) || in_array('webmaster', array_values($user->roles))) {
      return TRUE;
    }
    else {
      // We check if the user has the prmission
      // in any of the assigned knowledge services.
      $gids = $node->og_group_ref[LANGUAGE_NONE];
      foreach ($gids as $gid) {
        $access = og_user_access('node', $gid['target_id'], 'unpublish ks content');
        if ($access == TRUE) {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_og_vocab_get_accessible_vocabs_alter().
 */
function know4pol_core_og_vocab_get_accessible_vocabs_alter(&$result) {
  $gids = array();
  $node = menu_get_object();
  if (!empty($node->og_group_ref)) {
    foreach ($node->og_group_ref[LANGUAGE_NONE] as $gid) {
      $gids[] = $gid['target_id'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node->type, $gids);
  }
  else {
    // We are in a "Add content" page.
    $node = menu_get_item();
    $url_parameters = drupal_get_query_parameters();
    if (!empty($url_parameters)) {
      $gids[] = $url_parameters['og_group_ref'];
    }
    $result = _know4pol_core_get_accessible_vocabs($node['page_arguments'][0], $gids);
  }
}

/**
 * Get all the vocabs a user may access.
 *
 * This will include the global vocabualries (i.e. ones that aren't associated
 * with a group), and the ones that are associated with a group the user is a
 * member.
 *
 * @param string $bundle
 *   The entity type.
 * @param array $gids
 *   The group ids.
 *
 * @return array
 *   An array with the vocabulary IDs or an empty array if no vocabulary
 *   was found.
 */
function _know4pol_core_get_accessible_vocabs($bundle, array $gids) {
  $vids = array();
  if ($gids) {
    $query = db_select('og_vocab', 'ogv');
    $query->join('og_vocab_relation', 'ovr', 'ogv.vid = ovr.vid');
    $query->fields('ogv', array('vid'))
      ->condition('gid', $gids, 'IN')
      ->condition('bundle', $bundle);
    $vids = $query->execute()->fetchAllAssoc('vid');
  }
  return $vids;
}

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function know4pol_core_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  $targets['field_tags']['callback'] = '_konw4pol_core_taxonomy_feeds_set_target';
  $targets['field_related_organisations:acronym']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:label']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_group_ref:etid']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary']['callback'] = '_know4pol_core_post_process_callback';
  $targets['og_vocabulary:label']['callback'] = '_know4pol_core_post_process_callback';
  if ($entity_type == 'node') {
    $content_type_og_vocabularies = _know4pol_core_get_og_vocabularies_by_content_type($bundle_name);
    foreach ($content_type_og_vocabularies as $vocab) {
      $targets['og_vocabulary:' . $vocab->machine_name]['name'] = 'og_vocabulary:' . $vocab->name;
      $targets['og_vocabulary:' . $vocab->machine_name]['callback'] = '_know4pol_core_post_process_callback';
      $targets['og_vocabulary:' . $vocab->machine_name]['summary_callbacks'] = array('taxonomy_feeds_summary_callback');
      $targets['og_vocabulary:' . $vocab->machine_name]['form_callbacks'] = array('taxonomy_feeds_form_callback');
    }
  }
}

/**
 * Callback for mapping taxonomy terms.
 */
function _konw4pol_core_taxonomy_feeds_set_target(FeedsSource $source, $entity, $target, array $terms, array $mapping) {
  $language = $mapping['language'];

  // Add in default values.
  $mapping += array(
    'term_search' => FEEDS_TAXONOMY_SEARCH_TERM_NAME,
    'autocreate' => FALSE,
  );

  $info = field_info_field($target);

  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache['allowed_values'][$target])) {
    $cache['allowed_values'][$target] = taxonomy_allowed_values($info);
  }

  if (!isset($cache['allowed_vocabularies'][$target])) {
    foreach ($info['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
        $cache['allowed_vocabularies'][$target][$vocabulary->vid] = $vocabulary->machine_name;
      }
    }
  }

  // Some kind of configuration issue. Perhaps the vocabulary was deleted.
  // Nothing we can do about it.
  if (empty($cache['allowed_vocabularies'][$target])) {
    return;
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', $cache['allowed_vocabularies'][$target])
    ->range(0, 1);

  $field = isset($entity->$target) ? $entity->$target : array($language => array());

  if (!isset($field[$language])) {
    $field[$language] = array();
  }

  // Allow for multiple mappings to the same target.
  $delta = count($field[$language]);

  // Iterate over all values.
  foreach ($terms as $term) {

    if ($info['cardinality'] == $delta) {
      break;
    }

    $tid = FALSE;

    // FeedsTermElement already is a term.
    if ($term instanceof FeedsTermElement) {
      $tid = $term->tid;
    }
    else {
      switch ($mapping['term_search']) {

        // Lookup by name.
        case FEEDS_TAXONOMY_SEARCH_TERM_NAME:
          $term = trim($term);
          $name_query = clone $query;
          if (drupal_strlen($term) && $tids = $name_query->propertyCondition('name', $term)->execute()) {

            // Find the first allowed term.
            foreach ($tids['taxonomy_term'] as $possible_term) {
              if (isset($cache['allowed_values'][$target][$possible_term->tid])) {
                $tid = $possible_term->tid;
                break;
              }
            }
          }
          elseif ($mapping['autocreate'] && drupal_strlen($term)) {
            $term = (object) array(
              'name' => drupal_substr($term, 0, 255),
              'vid' => key($cache['allowed_vocabularies'][$target]),
              'vocabulary_machine_name' => reset($cache['allowed_vocabularies'][$target]),
            );
            // Set language if the taxonomy is multilingual.
            if ($language !== LANGUAGE_NONE) {
              $info = entity_get_info('taxonomy_term');
              if (!empty($info['entity keys']['language'])) {
                $term->{$info['entity keys']['language']} = $language;
              }
            }
            taxonomy_term_save($term);
            $tid = $term->tid;
            // Add to the list of allowed values.
            $cache['allowed_values'][$target][$tid] = $term->name;
          }
          break;

        // Lookup by tid.
        case FEEDS_TAXONOMY_SEARCH_TERM_ID:
          if (is_numeric($term)) {
            $tid = (int) $term;
          }
          break;

        // Lookup by GUID.
        case FEEDS_TAXONOMY_SEARCH_TERM_GUID:
          $tid = taxonomy_feeds_term_lookup_term_by_guid($term);
          break;
      }
    }

    if ($tid && isset($cache['allowed_values'][$target][$tid])) {
      $field[$language][] = array('tid' => $tid);
      $delta++;
    }
  }

  // Then we get the status before processing the import.
  $entity_unchanged = entity_load_unchanged($entity->feeds_item->entity_type, $entity->nid);
  // The customisation of the callback is only for the field "og_group_ref".
  $existing_field_tags = $entity_unchanged->field_tags;
  if (!empty($existing_field_tags) && $target == 'field_tags') {
    $entity->field_tags = $existing_field_tags;
    foreach ($field[LANGUAGE_NONE] as $value) {
      if (!in_array($value, $entity->field_tags[LANGUAGE_NONE])) {
        array_push($entity->field_tags[LANGUAGE_NONE], $value);
      }
    }
  }
  else {
    $entity->$target = $field;
  }
}

/**
 * Get all Vocabularies related to a group.
 */
function _know4pol_core_get_og_vocabularies_by_content_type($bundle_name) {
  $query = db_select('og_vocab', 'ov');
  $query->join('taxonomy_vocabulary', 'tv', 'tv.vid = ov.vid');
  $query->fields('ov', array('vid'))
    ->fields('tv', array('name', 'machine_name'))
    ->condition('bundle', $bundle_name);
  $result = $query->execute()->fetchAll();
  return $result;
}

/**
 * Custom Entity reference callback for "og_group_ref"/"og_vocab" field mapping.
 *
 * When the callback is invoked, $target contains the name of the field the
 * user has decided to map to and $value contains the value of the feed item
 * element the user has picked as a source.
 *
 * @param FeedsSource $source
 *   A FeedsSource object.
 * @param object $entity
 *   The entity to map to.
 * @param string $target
 *   The target key on $entity to map to.
 * @param array $value
 *   The value to map. MUST be an array.
 */
function _know4pol_core_post_process_callback(FeedsSource $source, $entity, $target, array $value, array $mapping) {
  // Add in default values.
  $mapping += array(
    'term_search' => FEEDS_TAXONOMY_SEARCH_TERM_NAME,
    'autocreate' => FALSE,
  );
  // First we define if the entity to change is a term or a node.
  if ($entity->feeds_item->entity_type == 'taxonomy_term') {
    $entity_id_key = 'tid';
  }
  else {
    $entity_id_key = 'nid';
  }
  // Then we get the status before processing the import.
  $entity_unchanged = entity_load_unchanged($entity->feeds_item->entity_type, $entity->$entity_id_key);
  // The customisation of the callback is only for the field "og_group_ref".
  $existing_og_group_ref = $entity_unchanged->og_group_ref;
  // Don't do anything if we weren't given any data.
  if (empty($value)) {
    return;
  }
  // Assume that the passed in value could really be any number of values.
  if (is_array($value)) {
    $values = $value;
  }
  else {
    $values = array($value);
  }
  // Determine the field we are matching against.
  if (strpos($target, ':') === FALSE) {
    $match_key = 'guid';
  }
  else {
    list($target, $match_key) = explode(':', $target, 2);
  }
  // Get some useful field information.
  $info = field_info_field($target);
  if ($match_key == 'label') {
    $handler = entityreference_get_selection_handler($info);
  }
  // Iterate over all values.
  $field = isset($entity->$target) ? $entity->$target : array();
  foreach ($values as $value) {
    // Only process if this value was set for this instance.
    if ($value) {
      switch ($match_key) {
        case 'guid':
        case 'url':
          // Fetch the entity ID resulting from the mapping table look-up.
          $entity_id = db_select('feeds_item', 'fi')
            ->fields('fi', array('entity_id'))
            ->condition($match_key, $value, '=')
            ->execute()
            ->fetchField();
          break;

        case 'etid':
          $entity_id = $value;
          break;

        case 'label':
          $options = $handler->getReferencableEntities($value, '=');
          if ($options) {
            // Change the logic for "og_vocabulary:label".
            if ($target == 'og_vocabulary') {
              foreach ($options as $key => $value) {
                $vocab = taxonomy_vocabulary_machine_name_load($key);
                $vocab_relation = og_vocab_relation_get($vocab->vid);
                if (!empty($vocab_relation)) {
                  $etids[] = array_keys($options[$key]);
                }
              }
              $og_vocabulary_term_ids = array_values($etids);
            }
            else {
              $options = reset($options);
              $etids = array_keys($options);
            }
          }
          // Use the first matching entity.
          $entity_id = reset($etids);
          break;

        default:
          // This is to assign items to a specific og vocabulary.
          if ($target == 'og_vocabulary') {
            // Get some useful field information.
            $info = field_info_field($target);
            $handler = entityreference_get_selection_handler($info);
            $options = $handler->getReferencableEntities($value, '=');
            if (!empty($options[$match_key])) {
              $etid = array_keys($options[$match_key]);
            }
            $entity_id = "";
            if (!empty($etid)) {
              $entity_id = reset($etid);
            }
            if ($mapping['autocreate']) {
              $mapping_target = drupal_substr($mapping['target'], drupal_strlen('og_vocabulary:'));
              $terms = taxonomy_get_term_by_name($value, $mapping_target);
              $term = reset($terms);
              if (empty($term)) {
                $vocab = taxonomy_vocabulary_machine_name_load($mapping_target);
                $vocab_id = $vocab->vid;
                $term = (object) array(
                  'name' => drupal_substr($value, 0, 255),
                  'vid' => $vocab_id,
                  'vocabulary_machine_name' => $mapping_target,
                );
                taxonomy_term_save($term);
              }
            }
          }
          if ($target == 'field_related_organisations') {
            // Get the related organisation nid.
            $query = db_select('node', 'n')
              ->fields('n', array('nid'));
            $query->join('field_data_field_org_acronym', 'oc', 'oc.entity_id = n.nid');
            $query->condition('n.type', 'organisation')
              ->condition('field_org_acronym_value', $value);

            $etid = $query->execute()->fetch();
            $entity_id = "";
            if (!empty($etid)) {
              $entity_id = $etid->nid;
            }
          }
          break;
      }
      /*
       * Only add a reference to an existing entity ID if there exists a
       * mapping between it and the provided GUID.  In cases where no such
       * mapping exists (yet), don't do anything here.  There may be a mapping
       * defined later in the CSV file.  If so, and the user re-runs the import
       * (as a second pass), we can add this reference then.  (The "Update
       * existing nodes" option must be selected during the second pass.)
       */
      if (isset($og_vocabulary_term_ids)) {
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        foreach ($og_vocabulary_term_ids as $key => $value) {
          // Assign the target ID.
          if (!in_array($value[0], $existing_target_ids)) {
            $field[LANGUAGE_NONE][]['target_id'] = (string) $value[0];
          }
        }
      }
      elseif ($entity_id) {
        // Assign the target ID.
        $existing_target_ids = array();
        foreach (array_values($field[LANGUAGE_NONE]) as $item) {
          $id = array_values($item);
          $existing_target_ids[] = $id[0];
        }
        if (!in_array($entity_id, $existing_target_ids)) {
          $field[LANGUAGE_NONE][]['target_id'] = (string) $entity_id;
        }
      }
      else /* there is no $entity_id, no mapping */ {
        /*
         * Feeds stores a hash of every line imported from CSVs in order to
         * make the import process more efficient by ignoring lines it's
         * already seen.  We need to short-circuit this process in this case
         * because users may want to re-import the same line as an update later
         * when (and if) a map to a reference exists.  So in order to provide
         * this opportunity later, we need to destroy the hash.
         */
        unset($entity->feeds_item->hash);
        $source->log('entityreference', t('No existing entity found for entity @source_id entityreference to source entity @value', array('@source_id' => $entity->feeds_item->entity_id, '@value' => $value)));
      }
    }
    // Break out of the loop if this field is single-valued.
    if ($info['cardinality'] == 1) {
      break;
    }
  }

  // If the "og_group_ref" field has an old value,
  // then add the old and the new value.
  // Otherwise just add the field to the entity definition.
  if (!empty($existing_og_group_ref) && $target == 'og_group_ref') {
    $entity->og_group_ref = drupal_array_merge_deep($existing_og_group_ref, $field);
  }
  else {
    $entity->{$target} = $field;
  }
  // KNOW4POL-490. Store this for the request so token can read from it.
  if ($target == 'og_group_ref') {
    $gids = &drupal_static('know4pol_core_og_group_ref');
    $gids = $entity->{$target};
    $gids = array_column($gids[LANGUAGE_NONE], 'target_id');
  }
}

/**
 * Implements hook_feeds_presave().
 */
function know4pol_core_feeds_presave(FeedsSource $source, $entity, $item, $entity_id) {
  // For all imports, if the content is imported as published,
  // then we set the moderation to published as well.
  // This is not handled by Workbench_moderation module.
  if ($entity->status == "1") {
    $entity->workbench_moderation_state_new = workbench_moderation_state_published();
  }
  // Check first if we have any topics from Newsroom.
  if (!empty($entity->field_newsroom_topics[LANGUAGE_NONE])) {
    foreach ($entity->field_newsroom_topics[LANGUAGE_NONE] as $value) {
      $matched_term_in_tags = "";
      $matched_term_in_knowledge_service_og = "";
      // For each topic, first we load it,
      // in order to get its category and name.
      $entity_term = taxonomy_term_load($value['tid']);
      // If the category is "Knowledge4Policy Keywords".
      if ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge4Policy Keywords") {
        // Then we search its equivalent in "tags" vocabulary.
        $matched_term_in_tags = taxonomy_get_term_by_name($entity_term->name, 'tags');
        if (!empty($matched_term_in_tags)) {
          $matched_term_in_tags = array_shift($matched_term_in_tags);
          // Add the tag to the imported entity.
          $poparray = function ($value) {
            return $value['tid'];
          };
          $entity_tags = array();
          if (!empty($entity->field_tags[LANGUAGE_NONE])) {
            $entity_tags = array_map($poparray, $entity->field_tags[LANGUAGE_NONE]);
            if (!in_array($matched_term_in_tags->tid, $entity_tags)) {
              $entity->field_tags[LANGUAGE_NONE][]['tid'] = $matched_term_in_tags->tid;
            }
          }
          else {
            $entity->field_tags[LANGUAGE_NONE][]['tid'] = $matched_term_in_tags->tid;
          }
        }
      }
      // Else if the category is "Knowledge Service".
      elseif ($entity_term->field_newsroom_category_domain['en'][0]['value'] == "Knowledge Service") {
        // Then we search in "knowledge_centre" content type.
        // because it's a node reference.
        $query = new EntityFieldQuery();
        $matched_term_in_knowledge_service_og = $query->entityCondition('entity_type', 'node')
          ->propertyCondition('type', 'knowledge_centre')
          ->propertyCondition('title', $entity_term->name)
          ->propertyCondition('status', 1)
          ->range(0, 1)
          ->execute();
        if (!empty($matched_term_in_knowledge_service_og)) {
          $matched_term_in_knowledge_service_og = array_shift($matched_term_in_knowledge_service_og['node']);
          // Add the related OG group to the imported entity.
          $entity->og_group_ref[LANGUAGE_NONE][]['target_id'] = $matched_term_in_knowledge_service_og->nid;
        }
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function know4pol_core_block_info() {
  $blocks = array();
  $blocks['know4pol_ks_latest_content'] = array(
    'info' => t('Know4pol KS latest content block'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['know4pol_ks_admin_menu'] = array(
    'info' => t('Know4pol KS admin block'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_theme().
 */
function know4pol_core_theme($existing, $type, $theme, $path) {
  $templates_path = sprintf('%s/templates', $path);
  return array(
    'latest_items' => array(
      'variables' => array(
        'items' => NULL,
      ),
      'template' => 'latest_items',
      'path' => $templates_path,
    ),
    'ks_admin_menu' => array(
      'variables' => array(
        'items' => NULL,
      ),
      'template' => 'ks_admin_menu',
      'path' => $templates_path,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function know4pol_core_block_view($delta = '') {
  $block = array();
  $items = array();

  switch ($delta) {
    case 'know4pol_ks_latest_content':
      // Are we viewing a node ?
      $node = menu_get_object();
      if (!$node->nid) {
        // We could check this is a group too.
        return;
      }
      // Get those 3 diplays.
      $displays = array(
        'latest_news',
        'next_events',
        'latest_resources',
      );

      foreach ($displays as $d) {
        $view = views_get_view('ks_latest_content');
        if (!$view || !$view->access($d)) {
          continue;
        }

        // Change settings for latest_resources.
        if ($d == $displays[2]) {
          $view->display[$d]->handler->options['filters']['type']['value'] =
            _know4pol_core_get_last_ressources_types(_know4pol_core_get_setting($node->nid, 'types_hidden', array()));
        }

        // Execute the view, retrieve data.
        $output = $view->preview($d, array($node->nid));

        if (count($view->result)) {
          $items[] = array(
            'title' => $view->get_title(),
            'content' => $output,
          );
        }
      }

      $block['content'] = theme('latest_items', array('items' => $items));
      break;

    case 'know4pol_ks_admin_menu':
      $block['content'] = theme('ks_admin_menu', array('items' => menu_tree_page_data('menu-ks-admin-menu')));
      break;
  }

  return $block;
}

/**
 * Implements hook_og_ui_get_group_admin().
 */
function know4pol_core_og_ui_get_group_admin($group_type, $gid) {
  $items = array();
  if (og_user_access($group_type, $gid, 'add user')) {
    $items['know4pol_content'] = array(
      'title' => t('View all KS content'),
      'description' => t('Manage all KS content'),
      'href' => 'admin/content',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_files'] = array(
      'title' => t('View all KS files'),
      'description' => t('Manage all KS files'),
      'href' => 'admin/files',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_sharing_content'] = array(
      'title' => t('Assign/Unassign content to KS'),
      'description' => t('Assign/Unassign content to KS'),
      'href' => 'admin/sharing-content',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_pubsy'] = array(
      'title' => t('Assign/Unassign Pubsy publications'),
      'description' => t('Assign/Unassign Pubsy publications'),
      'href' => 'admin/pubsy',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
    $items['know4pol_suggest_content'] = array(
      'title' => t('Suggest content to KS'),
      'description' => t('Suggest content to KS'),
      'href' => 'admin/suggest-content',
      'access callback' => 'og_ui_user_access_group',
      'access arguments' => array('add user', 1, 2),
    );
  }
  return $items;
}

/**
 * Implements hook_menu().
 */
function know4pol_core_menu() {
  $items = array();
  $items['group/node/%/admin/settings'] = array(
    'title' => 'KS Settings',
    'description' => "Configure KS landing page settings",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('know4pol_core_ks_settings_form', 2),
    'access arguments' => array('administer ks settings', 'node', 2),
    'access callback' => '_know4pol_core_get_og_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/know4pol_core_settings.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function know4pol_core_menu_alter(&$items) {
  $items['node/add']['access callback'] = '_know4pol_core_node_add_access';
  $items['admin/index']['access callback'] = '_know4pol_core_node_add_access';
  $items['admin/workbench/create']['access callback'] = '_know4pol_core_node_add_access';
  $items['group/node/%/admin/content']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/content']['access arguments'] = array('view manage KS content section',
    'node',
    2,
  );
  $items['group/node/%/admin/files']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/files']['access arguments'] = array('view manage KS content section',
    'node',
    2,
  );
  $items['group/node/%/admin/sharing-content']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/sharing-content']['access arguments'] = array('assign and unassign ks content',
    'node',
    2,
  );
  $items['group/node/%/admin/pubsy']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/pubsy']['access arguments'] = array('assign and unassign ks content',
    'node',
    2,
  );
  $items['group/node/%/admin/suggest-content']['access callback'] = '_know4pol_core_get_og_access';
  $items['group/node/%/admin/suggest-content']['access arguments'] = array('suggest ks content',
    'node',
    2,
  );
  $items['node/%node/moderation/%/unpublish']['access callback'] = '_know4pol_core_unpublish_access';
  $items['node/%node/moderation/%/unpublish']['access arguments'] = array(1);
}

/**
 * Access callback: check if the user has the given OG permission.
 *
 * @param string $perm
 *   The permission to check.
 * @param string $group_type
 *   The group type.
 * @param string $gid
 *   The group id.
 */
function _know4pol_core_get_og_access($perm, $group_type, $gid) {
  $gid = (int) $gid;
  return ($gid > 0 && og_user_access($group_type, $gid, $perm));
}

/**
 * Access callback: function for add content menu item.
 *
 * @return bool
 *   TRUE if the user has add permission, otherwise FALSE.
 *
 * @see _node_add_access()
 */
function _know4pol_core_node_add_access() {
  if (user_access('administer nodes')) {
    return _node_add_access();
  }
  return FALSE;
}

/**
 * Implements hook_action_info().
 */
function know4pol_core_action_info() {
  return array(
    '_know4pol_core_assign_ks_action' => array(
      'type' => 'node',
      'label' => t('Assign content to the current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    '_know4pol_core_unassign_ks_action' => array(
      'type' => 'node',
      'label' => t('Remove content from the current KS'),
      'behavior' => array('creates_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    '_know4pol_core_suggest_ks_action' => array(
      'type' => 'node',
      'label' => t('Suggest content to be part of the current KS'),
      'behavior' => array('views_property'),
      'configurable' => FALSE,
      'vbo_configurable' => TRUE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $settings
 *   The action settings.
 * @param array $form_state
 *   The form states.
 */
function _know4pol_core_suggest_ks_action_form($settings, array &$form_state) {
  $nodes = node_load_multiple($form_state['selection']);
  $nodes_nid = array();
  $nodes_title = "<ul>";
  foreach ($nodes as $node) {
    $nodes_nid[] = $node->nid;
    $nodes_title .= '<li>' . $node->title . '</li>';
  }
  $nodes_nid = implode('|', $nodes_nid);
  $nodes_title .= "</ul>";
  $form = array();
  $form['question'] = array(
    '#markup' => t("<p><strong>You're about to notify all the actual KS editors that the following selected content are a good candidate for the actual KS. Do you confirm?</strong></p>"),
  );
  $form['nodes_title'] = array(
    '#markup' => $nodes_title,
  );
  $form['nodes_nid'] = array(
    '#type' => 'hidden',
    '#value' => $nodes_nid,
  );
  return $form;
}

/**
 * The submit function for know4pol_ks_action_info.
 *
 * @param array $form
 *   The form.
 * @param array $form_state
 *   The form states.
 */
function _know4pol_core_suggest_ks_action_submit(array $form, array $form_state) {
  $path = explode('/', current_path());
  $gid = $path['2'];
  $ks_editors = _know4pol_core_get_og_group_members_mails($gid, array('editor member'));
  $ks_editors = implode(',', $ks_editors);
  drupal_mail('know4pol_core', 'suggest_ks_editors', $ks_editors, language_default(),
               array(
                 'nodes_title' => $form['nodes_title']["#markup"],
                 'nodes_nid' => $form['nodes_nid']["#value"],
                 'current_path' => 'group/node/' . $gid . '/admin/sharing-content',
               ));
}

/**
 * Implements hook_mail().
 */
function know4pol_core_mail($key, &$message, $params) {
  global $user, $base_url;
  $user_realname = format_username($user);
  if ($key == 'suggest_ks_editors') {
    $message['subject'] = t('Suggestion from your knowledge service on Knowledge4policy website');
    $body = "Dear editors,\n\n"
            . $user_realname . " suggets that you assign the following content to your knowledge service:\n\n"
            . $params['nodes_title']
            . "\nPlease go to this admin page in order to see and assign them to your knowledge service:\n"
            . $base_url . "/" . $params['current_path'] . "?nid=" . $params['nodes_nid']
            . "\nThis is an automatic email, please do not reply.\nThanks,\nKnowledge4policy team";
    $message['body'][] = $body;
  }
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_assign_ks_action($entity, array $context) {
  $entity->og_group_ref[LANGUAGE_NONE][]['target_id'] = $context['view_info']['arguments'][0];
  // Only for Pubsy publications,
  // Publish the node.
  if ($entity->status == 0 &&
      $entity->type == 'publication' &&
      !empty($entity->field_pub_dc_rel_ispartofseries[LANGUAGE_NONE][0]['value'])) {
    $entity->status = 1;
  }
  node_save($entity);
}

/**
 * The action function for know4pol_ks_action_info.
 *
 * @param object $entity
 *   Entity to change og_group_ref field.
 * @param array $context
 *   Optional values coming from VBO form.
 */
function _know4pol_core_unassign_ks_action($entity, array $context) {
  $target_group_id = $context['view_info']['arguments'][0];
  $og_array = $entity->og_group_ref[LANGUAGE_NONE];
  foreach ($og_array as $key => $value) {
    if ($value['target_id'] == $target_group_id) {
      unset($og_array[$key]);
    }
  }
  $entity->og_group_ref[LANGUAGE_NONE] = array_values($og_array);
  // Only for Pubsy publications,
  // Unpublish the node if no other KS attached.
  if ($entity->status == 1 &&
      $entity->type == 'publication' &&
      !empty($entity->field_pub_dc_rel_ispartofseries[LANGUAGE_NONE][0]['value']) &&
      empty($entity->og_group_ref[LANGUAGE_NONE][0]['target_id'])) {
    $entity->status = 0;
  }
  node_save($entity);
}

/**
 * Implements hook_field_display_alter().
 */
function know4pol_core_field_display_alter(&$display, $context) {
  // Add the <p> tag to the field_ne_body summary, if not available.
  if (isset($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->field_ne_body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
  // Add the <p> tag to the body summary, if not available.
  if (isset($context['entity']->body[LANGUAGE_NONE][0]['summary']) && !empty($context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
    if (!preg_match('/\<p\>/', $context['entity']->body[LANGUAGE_NONE][0]['summary'])) {
      $context['entity']->body[LANGUAGE_NONE][0]['summary'] = "<p>" . $context['entity']->body[LANGUAGE_NONE][0]['summary'] . "</p>";
    }
  }
}

/**
 * Implements hook_preprocess_html().
 */
function know4pol_core_preprocess_html(&$variables) {
  global $theme;
  if ($theme == 'seven') {
    drupal_add_css(drupal_get_path('module', 'know4pol_core') . '/css/know4pol_core_admin.css');
  }
}

/**
 * Implements hook_webform_select_options_info().
 */
function know4pol_core_webform_select_options_info() {
  $items = array();
  $items['states'] = array(
    'title' => t('Knowledge services'),
    'options callback' => '_know4pol_core_webform_options_knowledge_services',
  );
  return $items;
}

/**
 * Get the list of all published KS names.
 *
 * @return array
 *   List of all published Knowledge services.
 */
function _know4pol_core_webform_options_knowledge_services() {
  $query = db_select('node', 'n')
    ->fields('n', array('nid', 'title'))
    ->condition('type', 'knowledge_centre')
    ->condition('status', 1);
  $knowledge_services = $query->execute()->fetchAllAssoc('nid');
  $ks_list = array();
  foreach ($knowledge_services as $nid => $knowledge_service) {
    $ks_list[$nid] = $knowledge_service->title;
  }
  return $ks_list;
}

/**
 * Implements hook_ds_fields_info().
 */
function know4pol_core_ds_fields_info($entity_type) {
  $fields = array();

  $fields['node']['ks_name_topic_specific_taxonomies'] = array(
    'title' => t('Knowledge service | Topics | Specific keywords'),
    'field_type' => DS_FIELD_TYPE_FUNCTION,
    'function' => '_know4pol_core_render_ks_name_topic_specific_taxonomies',
  );

  return $fields;
}

/**
 * Helper function that creates a custom ds field.
 *
 * @param array $field
 *   All information on the field and its parent entity.
 *
 * @return string
 *   Space, to have it render.
 */
function _know4pol_core_render_ks_name_topic_specific_taxonomies(array $field) {
  $content = "";
  $menu = menu_get_item();

  // Let's define the three fields to be shown.
  $knowledge_services_topics = isset($menu['page_arguments'][0]->field_ks_related_topics[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->field_ks_related_topics[LANGUAGE_NONE] : array();
  $knowledge_services_specific_keywords = isset($menu['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->og_vocabulary[LANGUAGE_NONE] : array();
  $knowledge_services = isset($menu['page_arguments'][0]->og_group_ref[LANGUAGE_NONE]) ? $menu['page_arguments'][0]->og_group_ref[LANGUAGE_NONE] : array();

  // Let's filter topics/specific keywords by knowledge service.
  foreach ($knowledge_services as $knowledge_service) {
    // Go to line for the new knowledege services.
    if ($content != "") {
      $content .= '<br>';
    }
    $content .= _know4pol_core_get_topic_keywords_fields_by_ks($knowledge_services_topics, $knowledge_services_specific_keywords, $knowledge_service);
  }
  return $content;
}

/**
 * Filter topics/specific keywords by knowledge service.
 *
 * @param array $knowledge_services_topics
 *   A list of topics.
 * @param array $knowledge_services_specific_keywords
 *   A list of specific keywords.
 * @param array $knowledge_service
 *   A knowledge service.
 *
 * @return string
 *   The rendered content.
 */
function _know4pol_core_get_topic_keywords_fields_by_ks(array $knowledge_services_topics, array $knowledge_services_specific_keywords, array $knowledge_service) {
  $content = "";
  // First add the name of the knowledge service.
  $knowledge_service_node = node_load($knowledge_service['target_id']);
  $ks_name = $knowledge_service_node->title;
  $ks_url_alias = $knowledge_service_node->path['alias'];
  $content .= l($ks_name, $ks_url_alias, array('attributes' => array('class' => array('ecl-tag__item', 'know4pol-main-resource-meta-link'))));

  // Second create the list of topics per knowledge service.
  $ks_topics_content = "";
  foreach ($knowledge_services_topics as $knowledge_services_topic) {
    $knowledge_services_topic_term = node_load($knowledge_services_topic['target_id']);
    if ($knowledge_services_topic_term->og_group_ref[LANGUAGE_NONE][0]['target_id'] == $knowledge_service['target_id']) {
      $ks_topics_content .= _know4pol_core_create_topic_link($knowledge_services_topic_term->title, $knowledge_services_topic_term->path['alias']);
    }
  }
  if ($ks_topics_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_topics_content);
  }

  // Third add the list of specific keywords per KS.
  // First get the default vocabulary from the knowledge service content type.
  $ks_keyword_content = "";
  if (isset($knowledge_service_node->field_the_main_ks_keywords_vocab[LANGUAGE_NONE][0]['target_id'])) {
    $main_ks_keywords_vocab_id = $knowledge_service_node->field_the_main_ks_keywords_vocab[LANGUAGE_NONE][0]['target_id'];
    $ks_terms = array_keys(entity_load('taxonomy_term', FALSE, array('vid' => $main_ks_keywords_vocab_id)));
    foreach ($knowledge_services_specific_keywords as $ks_keyword) {
      if (in_array($ks_keyword['target_id'], $ks_terms)) {
        $ks_keyword_content .= _know4pol_core_create_keyword_content_link($ks_keyword, $knowledge_service);
      }
    }
  }
  if ($ks_keyword_content != "") {
    $content .= _know4pol_core_add_seperation_bar($ks_keyword_content);
  }

  return $content;
}

/**
 * Create the topic link.
 *
 * @param string $ks_topics_content_title
 *   A knowledge service topic.
 * @param string $ks_topics_content_path
 *   A knowledge service topic.
 */
function _know4pol_core_create_topic_link($ks_topics_content_title, $ks_topics_content_path) {
  return l($ks_topics_content_title, $ks_topics_content_path, array('attributes' => array('class' => array('ecl-tag__item'))));
}

/**
 * Create the keyword link.
 *
 * @param array $ks_keyword
 *   A Knowledge service keyword.
 * @param array $knowledge_service
 *   The related knowledge service.
 */
function _know4pol_core_create_keyword_content_link(array $ks_keyword, array $knowledge_service) {
  global $base_url;
  $ks_keyword_term = taxonomy_term_load($ks_keyword['target_id']);
  $ks_keyword_content_title = $ks_keyword_term->name;
  $ks_keyword_content_path = $base_url . '/search/site';
  return l($ks_keyword_content_title, $ks_keyword_content_path,
                                array(
                                  'attributes' => array('class' => array('ecl-tag__item')),
                                  'query' => array('f[0]' => 'sm_og_vocabulary:taxonomy_term:' . $ks_keyword_term->tid, 'f[1]' => 'sm_og_group_ref:node:' . $knowledge_service['target_id']),
                                ));
}

/**
 * Add "|" sign before the given text.
 *
 * @param string $content
 *   The content to be changed.
 */
function _know4pol_core_add_seperation_bar($content) {
  return '|' . $content;
}

/**
 * Implements hook_webform_submission_presave().
 */
function know4pol_core_webform_submission_presave(&$node, &$submission) {
  // Feedback form.
  if ($submission->nid == 31016) {
    // KS field filled && OG module enabled.
    if (module_exists('og') && drupal_strlen($submission->data[1][0])) {
      // Get OG group editors and append mails.
      foreach (_know4pol_core_get_og_group_members_mails($submission->data[1][0], array('editor member')) as $user_mail) {
        $node->webform['emails'][1]['email'] .= ',' . $user_mail;
      }
    }
  }
}

/**
 * Get users from an og group, with a given role .
 *
 * @param int $gid
 *   The group id.
 * @param array $roles
 *   The role(s) the users must have in the group.
 *
 * @return array
 *   An array of users
 */
function _know4pol_core_get_og_group_members_mails($gid, array $roles = array()) {
  // Check it's a group and load it.
  if (og_is_group('node', $gid)) {
    // Check if the $roles list is an array.
    if (!is_array($roles)) {
      $roles = array($roles);
    }
    // Get the group node information.
    $group = node_load($gid);

    // Get the mail list of the members.
    $mail_list = "";
    $members = og_get_group_members_properties($group, array(), 'members__' . OG_STATE_ACTIVE, 'node');
    foreach ($members as $uid) {
      if (count(array_intersect(og_get_user_roles($group->entity_type, $gid, $uid), $roles)) > 0) {
        $user = user_load($uid);
        $mail_list[$user->mail] = $user->mail;
      }
    }

    // Add the Official KS mails, if exist.
    if (!empty($group->field_official_ks_notif_mails[LANGUAGE_NONE])) {
      foreach ($group->field_official_ks_notif_mails[LANGUAGE_NONE] as $ks_mail) {
        $mail_list[$ks_mail['email']] = $ks_mail['email'];
      }
    }
    return count($mail_list) ? $mail_list : NULL;
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function know4pol_core_entity_property_info_alter(&$info) {
  $info['node']['properties']['current-revision-author-username'] = array(
    'label' => t('Current revision author username'),
    'type' => 'text',
    'description' => t('The username of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-realname'] = array(
    'label' => t('Current revision author realname'),
    'type' => 'text',
    'description' => t('The realname of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
  $info['node']['properties']['current-revision-author-mail'] = array(
    'label' => t('Current revision author email'),
    'type' => 'text',
    'description' => t('The email of the author of the current revision of the node.'),
    'computed' => TRUE,
    'field' => FALSE,
  );
}

/**
 * Implements hook_multisite_drupal_toolbox_filter_options_alter().
 */
function know4pol_core_multisite_drupal_toolbox_filter_options_alter(&$filter_options) {
  // Enable the <iframe> tag, strongly not advised of course.
  $filter_options['valid_elements']['iframe'] = array('*' => TRUE);
}

// The default time that will be used, until Admin sets a different value.
define('KNOW4POL_CORE_LASTUPDATE_DATE_FORMAT', 'Y-m-d H:i:s');

/**
 * Implements hook_form_alter().
 */
function know4pol_core_form_alter(&$form, $form_state) {

  // On edit node form.
  if (!empty($form['#node_edit_form'])
    // The last update field exists.
    && isset($form['field_last_update'])
    // It's not a new node.
    && $form['nid']['#value'] != NULL) {

    // Find publishing interface with access.
    foreach (array('options', 'revision_information', NULL) as $itf) {
      if ($itf && $form[$itf]['#access'] == TRUE) {
        break;
      }
    }
    // No valid interface found.
    if ($itf == NULL) {
      return;
    }

    $form[$itf]['workbench_moderation_state_new']['#weight'] = 2;
    $form[$itf]['no_last_update'] = array(
      '#type' => 'checkbox',
      '#title' => t('No automatic change of the last update date'),
      '#description' => t('Unless checked, the last update will be set to @datenow', array(
        '@datenow' => format_date(time(), 'custom', KNOW4POL_CORE_LASTUPDATE_DATE_FORMAT),
      )),
      '#default_value' => FALSE,
      '#weight' => 1,
    );

    if (module_exists("workbench_moderation")) {
      $form[$itf]['no_last_update']['#states'] = array(
        'visible' => array(
          'select[name="workbench_moderation_state_new"]' => array('value' => 'published'),
        ),
      );
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function know4pol_core_node_presave($node) {
  // New node or does not list the field ?
  if ($node->is_new || !isset($node->field_last_update)) {
    return;
  }
  // If using workbench_moderation, only process if getting published.
  if (module_exists("workbench_moderation") && $node->workbench_moderation_state_new != "published") {
    return;
  }
  // Is the checkbox there and cheked ?
  if (!isset($node->no_last_update) || $node->no_last_update) {
    return;
  }

  // Update the date.
  $node->field_last_update[LANGUAGE_NONE][0]['value'] = format_date(time(), 'custom', KNOW4POL_CORE_LASTUPDATE_DATE_FORMAT);
  $node->field_last_update[LANGUAGE_NONE][0]['value2'] = $node->field_last_update[LANGUAGE_NONE][0]['value'];
}
